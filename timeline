#!/bin/bash

# Timeline - git-based timeline utility for tracking file changes
# Usage: 
#   - Called automatically by Claude Code after tool use (no args)
#   - timeline list             - List all timelines
#   - timeline travel <number>    - Travel to a specific timeline by number
#   - timeline travel <commit-id> - Travel to a specific git commit
#   - timeline install          - Install hook to Claude Code
#   - timeline uninstall        - Remove hook from Claude Code

set -e

# Auto-detect script location
SCRIPT_PATH="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"

# Shared function to display session stats line
display_session_stats() {
    local session_id="$1"
    local prefix="${2:-}"  # Optional prefix text
    
    # Try different possible paths for the session file
    local session_file=""
    for path in "$HOME/.claude/projects/-Users-steven-chong-Downloads-repos-timeline/${session_id}.jsonl" \
                "$HOME/.claude/projects/"*"/${session_id}.jsonl"; do
        if [ -f "$path" ]; then
            session_file="$path"
            break
        fi
    done
    
    if [ -f "$session_file" ]; then
        # Get stats: timestamp, total messages, user prompts
        # Find first line with timestamp (not all lines have it)
        first_timestamp=$(grep -m 1 '"timestamp"' "$session_file" 2>/dev/null | jq -r '.timestamp // empty' 2>/dev/null)
        total_lines=$(wc -l < "$session_file" 2>/dev/null | tr -d ' ')
        user_messages=$(grep -c '"role":"user"' "$session_file" 2>/dev/null || echo "0")
        
        # Format stats line
        if [ -n "$first_timestamp" ]; then
            date_part=$(echo "$first_timestamp" | cut -d'T' -f1)
            time_part=$(echo "$first_timestamp" | cut -d'T' -f2 | cut -d'.' -f1)
            echo "${prefix}${date_part} ${time_part} | ${total_lines} messages, ${user_messages} user prompts"
        else
            echo "${prefix}Session: ${session_id} | ${total_lines} messages"
        fi
        
        # Return the session file path for further use
        echo "$session_file" > /tmp/timeline_session_file_$$
        return 0
    else
        echo "${prefix}Session: ${session_id}"
        return 1
    fi
}

# Shared function to display first user message (2 lines)
display_first_user_message() {
    local session_file="$1"
    local indent="${2:-  }"  # Default indent
    
    if [ -f "$session_file" ]; then
        # Try different JSON structures for user messages
        # Some have .message.content as string, some as array
        first_user_msg=$(grep '"role":"user"' "$session_file" 2>/dev/null | head -1 | jq -r '
            if .message.content | type == "string" then 
                .message.content
            elif .message.content | type == "array" then
                .message.content[0].text // empty
            else
                empty
            end' 2>/dev/null)
        
        if [ -n "$first_user_msg" ]; then
            # Default to 120 characters width
            WIDTH=120
            # Reserve some space for indent and quotes
            WIDTH=$((WIDTH - ${#indent} - 6))
            
            # Get first 2 lines, using available width (max 500)
            line1=$(echo "$first_user_msg" | head -1 | cut -c1-${WIDTH})
            line2=$(echo "$first_user_msg" | head -2 | tail -1 | cut -c1-${WIDTH})
            
            if [ -n "$line1" ]; then
                echo "${indent}💬 \"${line1}"
                if [ -n "$line2" ] && [ "$line1" != "$line2" ]; then
                    echo "${indent}    ${line2}\""
                else
                    echo "${indent}    ...\""
                fi
            fi
        fi
    fi
}

# Function to find current Claude Code session JSONL
get_current_claude_session() {
    local PROJECT_DIR="$HOME/.claude/projects"
    if [ -d "$PROJECT_DIR" ]; then
        # Find the project directory that matches our current working directory
        # Claude encodes paths but may have variations in encoding  
        local CWD=$(pwd)
        local PROJECT_PATH=""
        
        # Try different encoding patterns that Claude might use
        for dir in "$PROJECT_DIR"/*; do
            if [ -d "$dir" ] && [[ "$(basename "$dir")" == *"timeline"* ]]; then
                PROJECT_PATH="$dir"
                break
            fi
        done
        
        if [ -d "$PROJECT_PATH" ]; then
            # Find the most recent JSONL file (current or most recent session)
            local LATEST_JSONL=$(find "$PROJECT_PATH" -name "*.jsonl" -type f -exec stat -f "%m %N" {} \; 2>/dev/null | sort -nr | head -1 | cut -d' ' -f2-)
            if [ -f "$LATEST_JSONL" ]; then
                # Extract just the session ID (UUID) from the filename
                basename "$LATEST_JSONL" .jsonl
                return 0
            fi
        fi
    fi
    return 1
}

# Shared function to generate summary line format [+X ~Y -Z] visual +adds -dels lines
generate_summary_line() {
    local added_files="$1"
    local modified_files="$2"
    local removed_files="$3"
    local adds="$4"
    local dels="$5"
    
    # Build file breakdown like [+5 ~3 -1]
    local file_breakdown="["
    if [ "$added_files" -gt 0 ]; then
        file_breakdown="${file_breakdown}+${added_files} "
    fi
    if [ "$modified_files" -gt 0 ]; then
        file_breakdown="${file_breakdown}~${modified_files} "
    fi
    if [ "$removed_files" -gt 0 ]; then
        file_breakdown="${file_breakdown}-${removed_files} "
    fi
    file_breakdown="${file_breakdown%% }]"
    
    # Create visual indicator
    local visual=""
    if [ "$adds" -gt 0 ]; then
        if [ "$adds" -lt 10 ]; then
            visual="${visual}$(printf -- '+%.0s' $(seq 1 $adds))"
        elif [ "$adds" -lt 50 ]; then
            visual="${visual}+++"
        elif [ "$adds" -lt 100 ]; then
            visual="${visual}+++++"
        else
            visual="${visual}+++++++"
        fi
    fi
    
    if [ "$dels" -gt 0 ]; then
        if [ "$dels" -lt 10 ]; then
            visual="${visual}$(printf -- '-%.0s' $(seq 1 $dels))"
        elif [ "$dels" -lt 50 ]; then
            visual="${visual}---"
        elif [ "$dels" -lt 100 ]; then
            visual="${visual}-----"
        else
            visual="${visual}-------"
        fi
    fi
    
    # Return the formatted line
    echo "${file_breakdown}  ${visual}  +${adds} -${dels} lines"
}

# Shared function to display file changes for a timeline
display_timeline_changes() {
    local BRANCH="$1"
    local COMPARE_REF="${2:-HEAD}"  # Default to HEAD if not specified
    
    # Show file breakdown with status indicators
    file_status=$(git diff --name-status "$COMPARE_REF" "$BRANCH" 2>/dev/null)
    if [ -n "$file_status" ]; then
        # Get file counts
        added_files=0
        modified_files=0
        removed_files=0
        
        added_files=$(echo "$file_status" | grep '^A' | wc -l | tr -d ' ')
        modified_files=$(echo "$file_status" | grep '^M' | wc -l | tr -d ' ')
        removed_files=$(echo "$file_status" | grep '^D' | wc -l | tr -d ' ')
        
        # Get line stats
        STATS=$(git diff --shortstat "$COMPARE_REF" "$BRANCH" 2>/dev/null | sed 's/files\? changed/files/' || echo "")
        ADDS=$(echo "$STATS" | grep -oE '[0-9]+ insertion' | grep -o '[0-9]*' | head -1)
        DELS=$(echo "$STATS" | grep -oE '[0-9]+ deletion' | grep -o '[0-9]*' | head -1)
        ADDS=${ADDS:-0}
        DELS=${DELS:-0}
        
        # Use shared function to generate summary line
        summary_line=$(generate_summary_line "$added_files" "$modified_files" "$removed_files" "$ADDS" "$DELS")
        printf "   %s\n" "$summary_line"
    else
        printf "   (no changes)\n"
    fi
}

# Shared function to display timeline entries
display_timeline() {
    local CURRENT_BRANCH="$1"
    local CURRENT_HEAD="$2"
    
    echo "⏰ Timeline for branch '$CURRENT_BRANCH':"
    echo ""
    
    # Get all timeline entries sorted by date (newest first), excluding backups
    ALL_TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-' | head -20))
    TIMELINES=()
    
    # Filter out timelines that are identical to HEAD
    for timeline in "${ALL_TIMELINES[@]}"; do
        if [ -n "$(git diff --name-only HEAD "$timeline" 2>/dev/null)" ]; then
            TIMELINES+=("$timeline")
        fi
    done
    
    if [ ${#TIMELINES[@]} -eq 0 ]; then
        echo "No timeline entries found for branch '$CURRENT_BRANCH'"
        return 1
    fi
    
    # Process each timeline (oldest first, newest last)
    # Note: TIMELINES array is sorted newest first, so we need to iterate in reverse
    for ((i=${#TIMELINES[@]}-1; i>=0; i--)); do
        # Calculate display index (0 = oldest, higher = newer)
        DISPLAY_INDEX=$((${#TIMELINES[@]} - 1 - i))
        BRANCH="${TIMELINES[$i]}"
        
        # Get timeline commit message
        SUBJECT=$(git log -1 --pretty=format:"%s" "$BRANCH" 2>/dev/null)
        timeline_info=$(echo "$SUBJECT" | sed 's/ - [0-9]* files$//')
        
        # Always compare against current HEAD to show what would change if you travel to this timeline
        STATS=$(git diff --shortstat HEAD "$BRANCH" 2>/dev/null | sed 's/files\? changed/files/' || echo "")
        
        # Format line
        printf "  %2d: %s\n" "$DISPLAY_INDEX" "$timeline_info"
        
        # Show file breakdown with status indicators
        file_status=$(git diff --name-status HEAD "$BRANCH" 2>/dev/null)
        if [ -n "$file_status" ]; then
            # Get file counts
            added_files=0
            modified_files=0
            removed_files=0
            
            added_files=$(echo "$file_status" | grep '^A' | wc -l | tr -d ' ')
            modified_files=$(echo "$file_status" | grep '^M' | wc -l | tr -d ' ')
            removed_files=$(echo "$file_status" | grep '^D' | wc -l | tr -d ' ')
            
            # Get line stats
            STATS=$(git diff --shortstat HEAD "$BRANCH" 2>/dev/null | sed 's/files\? changed/files/' || echo "")
            ADDS=$(echo "$STATS" | grep -oE '[0-9]+ insertion' | grep -o '[0-9]*' | head -1)
            DELS=$(echo "$STATS" | grep -oE '[0-9]+ deletion' | grep -o '[0-9]*' | head -1)
            ADDS=${ADDS:-0}
            DELS=${DELS:-0}
            
            # Use shared function to generate summary line
            summary_line=$(generate_summary_line "$added_files" "$modified_files" "$removed_files" "$ADDS" "$DELS")
            printf "      %s\n" "$summary_line"
        else
            printf "      (no changes)\n"
        fi
    done
    
    return 0
}

# Handle command line arguments
if [ $# -gt 0 ]; then
    case "$1" in
        "save")
            # Explicit timeline creation - continue to timeline logic below
            ;;
        "install")
            # Use environment variable if set, otherwise default to ~/.claude
            CLAUDE_DIR="${CLAUDE_CONFIG_DIR:-$HOME/.claude}"
            SETTINGS_FILE="$CLAUDE_DIR/settings.json"
            
            echo "🚀 Timeline Hook Installer"
            echo "========================="
            echo ""
            
            if [ ! -f "$SETTINGS_FILE" ]; then
                echo "❌ Claude Code settings file not found at: $SETTINGS_FILE"
                echo "Please make sure Claude Code is installed and configured."
                exit 1
            fi
            
            # Check if already installed (check for script path patterns)
            if grep -q "timeline" "$SETTINGS_FILE"; then
                echo "✅ Timeline hook is already installed in Claude Code settings"
                echo "Current hook references in settings.json:"
                grep -n "timeline" "$SETTINGS_FILE" | head -3
                exit 0
            fi
            
            # Create backup
            cp "$SETTINGS_FILE" "$SETTINGS_FILE.backup"
            echo "📋 Backed up settings to: $SETTINGS_FILE.backup"
            
            # Install hook using jq (similar to claude-lsp-cli installer)
            if command -v jq &> /dev/null; then
                # Add to BOTH PreToolUse and PostToolUse hooks
                # PreToolUse catches state before destructive commands (git checkout, etc)
                # PostToolUse catches state after file edits
                
                # First, add to PostToolUse
                jq --arg cmd "$SCRIPT_PATH save" '.hooks.PostToolUse = ((.hooks.PostToolUse // []) | 
                    if length > 0 and .[0].hooks then
                        if (.[0].hooks | map(.command) | any(contains("timeline"))) then
                            .
                        else
                            .[0].hooks += [{"type": "command", "command": $cmd}]
                        end
                    else
                        . + [{"hooks": [{"type": "command", "command": $cmd}]}]
                    end)' "$SETTINGS_FILE.backup" > "$SETTINGS_FILE.tmp"
                
                # Then, add to PreToolUse (for Bash commands that might destroy changes)
                jq --arg cmd "$SCRIPT_PATH save" '.hooks.PreToolUse = ((.hooks.PreToolUse // []) | 
                    if length > 0 then
                        # Look for Bash matcher
                        map(if .matcher == "Bash" then
                            if (.hooks | map(.command) | any(contains("timeline"))) then
                                .
                            else
                                .hooks += [{"type": "command", "command": $cmd}]
                            end
                        else
                            .
                        end)
                    else
                        # Create new PreToolUse with Bash matcher
                        . + [{"matcher": "Bash", "hooks": [{"type": "command", "command": $cmd}]}]
                    end)' "$SETTINGS_FILE.tmp" > "$SETTINGS_FILE"
                
                rm -f "$SETTINGS_FILE.backup" "$SETTINGS_FILE.tmp"
                echo "✅ Installed timeline hooks to settings.json (Pre and Post)"
            else
                echo "⚠️  jq not found - please manually add hook to settings.json:"
                echo "  Add to PostToolUse hooks array: {\"type\": \"command\", \"command\": \"$SCRIPT_PATH save\"}"
                echo ""
                echo "Install jq for automatic hook management:"
                echo "  brew install jq  # macOS"
                echo "  apt install jq   # Ubuntu/Debian"
                exit 1
            fi
            
            echo ""
            echo "🎉 Timeline hook installation complete!"
            echo "The hook will now automatically create timeline timelines after any Claude Code tool use."
            echo ""
            echo "Available commands:"
            echo "  timeline travel           - Show and travel to timelines"
            echo "  timeline delete           - Delete timelines"
            echo "  timeline cleanup          - Clean up timelines for deleted branches"
            echo "  timeline uninstall        - Remove the hook"
            echo ""
            echo "Timeline timelines will be stored in: timelines/<branch-name>/"
            exit 0
            ;;
        "uninstall")
            # Use environment variable if set, otherwise default to ~/.claude
            CLAUDE_DIR="${CLAUDE_CONFIG_DIR:-$HOME/.claude}"
            SETTINGS_FILE="$CLAUDE_DIR/settings.json"
            
            echo "🗑️  Timeline Hook Uninstaller"
            echo "============================="
            echo ""
            
            if [ ! -f "$SETTINGS_FILE" ]; then
                echo "❌ Claude Code settings file not found at: $SETTINGS_FILE"
                exit 1
            fi
            
            # Check if hook is installed (check for any timeline references)
            if ! grep -q "timeline" "$SETTINGS_FILE"; then
                echo "✅ Timeline hook is not currently installed"
                exit 0
            fi
            
            echo "Current hook references found:"
            grep -n "timeline" "$SETTINGS_FILE" | head -3
            
            # Create backup
            cp "$SETTINGS_FILE" "$SETTINGS_FILE.backup"
            echo "📋 Backed up settings to: $SETTINGS_FILE.backup"
            
            # Remove hook using jq (similar to claude-lsp-cli installer logic)
            if command -v jq &> /dev/null; then
                # Remove timeline hooks from both PostToolUse and PreToolUse
                jq '.hooks.PostToolUse = ((.hooks.PostToolUse // []) | 
                    map(.hooks = (.hooks | map(select(.command | test("timeline") | not)))))' "$SETTINGS_FILE.backup" > "$SETTINGS_FILE.tmp"
                
                # Also remove from PreToolUse
                jq '.hooks.PreToolUse = ((.hooks.PreToolUse // []) | 
                    map(if .hooks then 
                        .hooks = (.hooks | map(select(.command | test("timeline") | not)))
                    else 
                        . 
                    end))' "$SETTINGS_FILE.tmp" > "$SETTINGS_FILE"
                
                rm -f "$SETTINGS_FILE.backup" "$SETTINGS_FILE.tmp"
                echo "✅ Timeline hooks removed from settings.json (Pre and Post)"
            else
                echo "⚠️  jq not found - please manually remove hook from settings.json"
                echo "Look for: {\"type\": \"command\", \"command\": \"$SCRIPT_PATH save\"}"
                exit 1
            fi
            
            echo ""
            echo "🗑️  Timeline hook uninstallation complete!"
            echo "The hook will no longer run automatically with Claude Code."
            echo "Your existing timeline timelines are preserved in the timelines/ directories."
            echo ""
            echo "To reinstall: timeline install"
            exit 0
            ;;
        "delete")
            # Interactive delete with options
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null || exit 0)
            
            # Display timeline using shared function
            echo "🗑️  Delete Timelines"
            echo "===================="
            if ! display_timeline "$CURRENT_BRANCH" "$CURRENT_HEAD"; then
                exit 0
            fi
            
            # Get timeline count for options
            TIMELINE_COUNT=$(git for-each-ref --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-' | wc -l | tr -d ' ')
            
            echo ""
            echo "Options:"
            echo "  a) Delete all timelines"
            echo "  0-$((TIMELINE_COUNT-1))) Delete specific timeline by number"
            echo "  x-y) Delete range of timelines (e.g., 0-11)"
            echo ""
            
            while true; do
                read -p "Select option (or press Enter to cancel): " choice
                
                # Handle cancel - empty input or quit commands
                if [ -z "$choice" ] || [ "$choice" = "q" ] || [ "$choice" = "Q" ] || [ "$choice" = "quit" ] || [ "$choice" = "exit" ] || [ "$choice" = "cancel" ]; then
                    echo "Cancelled."
                    exit 0
                fi
                
                case "$choice" in
                    "a"|"A")
                        echo ""
                        echo "⚠️  This will permanently delete ALL $TIMELINE_COUNT timelines."
                        read -p "Are you sure? (y/N): " -n 1 -r
                        echo
                        if [[ $REPLY =~ ^[Yy]$ ]]; then
                            git for-each-ref --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" | grep -v '/backup-' | \
                                xargs -I {} git branch -D {} >/dev/null 2>&1
                            echo "✅ Deleted $TIMELINE_COUNT timelines"
                        else
                            echo "Cancelled."
                        fi
                        exit 0
                        ;;
                    *)
                        # Check for range (e.g., 0-11)
                        if [[ "$choice" =~ ^([0-9]+)-([0-9]+)$ ]]; then
                            START="${BASH_REMATCH[1]}"
                            END="${BASH_REMATCH[2]}"
                            
                            # Validate range
                            if [ "$START" -ge 0 ] && [ "$END" -lt "$TIMELINE_COUNT" ] && [ "$START" -le "$END" ]; then
                                RANGE_COUNT=$((END - START + 1))
                                echo ""
                                echo "⚠️  This will delete $RANGE_COUNT timelines (from #$START to #$END)"
                                read -p "Are you sure? (y/N): " -n 1 -r
                                echo
                                if [[ $REPLY =~ ^[Yy]$ ]]; then
                                    # Get all timeline branches in order
                                    TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-'))
                                    
                                    # Delete the range (convert display indices to array indices)
                                    for i in $(seq $START $END); do
                                        ARRAY_INDEX=$((${#TIMELINES[@]} - 1 - i))
                                        if [ $ARRAY_INDEX -ge 0 ] && [ $ARRAY_INDEX -lt ${#TIMELINES[@]} ]; then
                                            git branch -D "${TIMELINES[$ARRAY_INDEX]}" >/dev/null 2>&1
                                        fi
                                    done
                                    echo "✅ Deleted $RANGE_COUNT timelines (#$START to #$END)"
                                else
                                    echo "Cancelled."
                                fi
                                exit 0
                            else
                                echo "Invalid range. Please use format like 0-11 within 0-$((TIMELINE_COUNT-1))"
                            fi
                        elif [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 0 ] && [ "$choice" -lt "$TIMELINE_COUNT" ]; then
                            # Get all timeline branches and convert display index to array index
                            TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-'))
                            ARRAY_INDEX=$((${#TIMELINES[@]} - 1 - choice))
                            TIMELINE_BRANCH="${TIMELINES[$ARRAY_INDEX]}"
                            
                            echo ""
                            echo "⚠️  Delete timeline: $TIMELINE_BRANCH?"
                            read -p "Are you sure? (y/N): " -n 1 -r
                            echo
                            if [[ $REPLY =~ ^[Yy]$ ]]; then
                                git branch -D "$TIMELINE_BRANCH" >/dev/null 2>&1
                                echo "✅ Deleted timeline #$choice"
                            else
                                echo "Cancelled."
                            fi
                            exit 0
                        else
                            echo "Invalid selection. Please choose a, 0-$((TIMELINE_COUNT-1)), x-y range, or press Enter to cancel."
                        fi
                        ;;
                esac
            done
            ;;
        "cleanup")
            echo "🧹 Cleanup Orphaned Timeline Branches"
            echo "======================================"
            echo ""
            
            # Get all existing branches (local and remote), excluding timeline branches  
            EXISTING_BRANCHES=$(git branch -a | sed 's/^[* ]*//' | grep -v 'timelines/' | sed 's/^remotes\///' | sort -u)
            
            # Find orphaned timeline branches
            ORPHANED_BRANCHES=()
            
            echo "Checking timeline branches..."
            ALL_TIMELINE_BRANCHES=$(git branch --list "timelines/*" | sed 's/^[\* ]*//')
            
            for timeline_branch in $ALL_TIMELINE_BRANCHES; do
                # Extract the base branch name from timelines/branch-name/timestamp
                base_branch=$(echo "$timeline_branch" | sed 's|^timelines/||' | cut -d'/' -f1)
                
                # Skip if base branch still exists
                if echo "$EXISTING_BRANCHES" | grep -qx "$base_branch" || \
                   echo "$EXISTING_BRANCHES" | grep -qx "origin/$base_branch"; then
                    continue
                fi
                
                # Get commit info
                commit_msg=$(git log --oneline -1 "$timeline_branch" 2>/dev/null | cut -d' ' -f2- || echo "")
                ORPHANED_BRANCHES+=("$timeline_branch:$base_branch:$commit_msg")
            done
            
            if [ ${#ORPHANED_BRANCHES[@]} -eq 0 ]; then
                echo "✅ No orphaned timeline branches found."
                exit 0
            fi
            
            echo "Found ${#ORPHANED_BRANCHES[@]} orphaned timeline branches:"
            echo ""
            
            # Display individual timeline branches with numbers
            for i in "${!ORPHANED_BRANCHES[@]}"; do
                IFS=':' read -r full_branch base_branch commit_msg <<< "${ORPHANED_BRANCHES[$i]}"
                printf "  %2d: %s\n" "$i" "$full_branch"
                printf "      %s\n" "$commit_msg"
            done
            
            echo ""
            echo "Options:"
            echo "  a) Remove all orphaned timeline branches"
            if [ ${#ORPHANED_BRANCHES[@]} -gt 0 ]; then
                echo "  0-$((${#ORPHANED_BRANCHES[@]} - 1))) Remove specific timeline by number"
            fi
            echo ""
            
            while true; do
                read -p "Select option (or press Enter to cancel): " choice
                
                # Handle cancel - empty input or quit commands
                if [ -z "$choice" ] || [ "$choice" = "q" ] || [ "$choice" = "Q" ] || [ "$choice" = "quit" ] || [ "$choice" = "exit" ] || [ "$choice" = "cancel" ]; then
                    echo "Cancelled."
                    exit 0
                fi
                
                case "$choice" in
                    "a"|"A")
                        echo ""
                        echo "⚠️  This will permanently delete ALL orphaned timeline branches."
                        read -p "Are you sure? (y/N): " -n 1 -r
                        echo ""
                        if [[ $REPLY =~ ^[Yy]$ ]]; then
                            for orphaned in "${ORPHANED_BRANCHES[@]}"; do
                                IFS=':' read -r full_branch _ _ <<< "$orphaned"
                                echo "🗑️  Removing branch: $full_branch"
                                git branch -D "$full_branch" 2>/dev/null || true
                            done
                            echo "✅ Removed ${#ORPHANED_BRANCHES[@]} orphaned timeline branches"
                        else
                            echo "Cancelled."
                        fi
                        exit 0
                        ;;
                    *)
                        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 0 ] && [ "$choice" -lt ${#ORPHANED_BRANCHES[@]} ]; then
                            # Get the selected timeline branch
                            IFS=':' read -r selected_branch _ _ <<< "${ORPHANED_BRANCHES[$choice]}"
                            
                            echo ""
                            echo "⚠️  This will permanently delete timeline: $selected_branch"
                            read -p "Are you sure? (y/N): " -n 1 -r
                            echo ""
                            if [[ $REPLY =~ ^[Yy]$ ]]; then
                                echo "🗑️  Removing branch: $selected_branch"
                                git branch -D "$selected_branch" 2>/dev/null || true
                                echo "✅ Removed timeline branch: $selected_branch"
                            else
                                echo "Cancelled."
                            fi
                            exit 0
                        else
                            echo "Invalid selection. Please choose a, 0-$((${#ORPHANED_BRANCHES[@]} - 1)), or press Enter to cancel."
                        fi
                        ;;
                esac
            done
            ;;
        "view")
            # Session-based view - select session first, then view timelines
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null)
            
            # First, let user select a session
            echo "🗂️ Available Sessions:"
            echo ""
            
            # Get all timeline branches and extract unique session IDs
            ALL_TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/*" 2>/dev/null))
            SESSION_LIST=()
            SEEN_SESSIONS=""
            
            for timeline in "${ALL_TIMELINES[@]}"; do
                # Get git notes to find session ID
                commit_hash=$(git rev-parse "$timeline" 2>/dev/null)
                if [ -n "$commit_hash" ]; then
                    notes=$(git notes --ref=timeline show "$commit_hash" 2>/dev/null || true)
                    if [ -n "$notes" ]; then
                        session_id=$(echo "$notes" | grep "^Session-Id:" | cut -d' ' -f2- | head -1)
                        if [ -n "$session_id" ] && ! echo "$SEEN_SESSIONS" | grep -q "$session_id"; then
                            SEEN_SESSIONS="$SEEN_SESSIONS $session_id"
                            SESSION_LIST+=("$session_id")
                        fi
                    fi
                fi
            done
            
            # If no sessions found, fall back to current session
            if [ ${#SESSION_LIST[@]} -eq 0 ]; then
                CURRENT_SESSION=$(get_current_claude_session)
                if [ -n "$CURRENT_SESSION" ]; then
                    session_id=$(basename "$CURRENT_SESSION" .jsonl)
                    SESSION_LIST=("$session_id")
                else
                    echo "No sessions found with timeline data"
                    exit 0
                fi
            fi
            
            # If only one session, auto-select it
            if [ ${#SESSION_LIST[@]} -eq 1 ]; then
                SELECTED_SESSION="${SESSION_LIST[0]}"
                
                echo "Auto-selected session:"
                # Use shared function to display stats
                display_session_stats "$SELECTED_SESSION" "  "
                
                # Show timeline stats for this session (total file/line changes)
                total_adds=0
                total_dels=0
                total_files=0
                timeline_count=0
                
                for timeline in "${ALL_TIMELINES[@]}"; do
                    commit_hash=$(git rev-parse "$timeline" 2>/dev/null)
                    if [ -n "$commit_hash" ]; then
                        # Check if this timeline belongs to this session
                        notes=$(git notes --ref=timeline show "$commit_hash" 2>/dev/null || true)
                        if [ -n "$notes" ]; then
                            session_id=$(echo "$notes" | grep "^Session-Id:" | cut -d' ' -f2- | head -1)
                            if [ "$session_id" = "$SELECTED_SESSION" ] || [ -z "$session_id" ]; then
                                # Count stats for this timeline
                                STATS=$(git diff --shortstat HEAD "$timeline" 2>/dev/null | sed 's/files\? changed/files/' || echo "")
                                if [ -n "$STATS" ]; then
                                    adds=$(echo "$STATS" | grep -oE '[0-9]+ insertion' | grep -o '[0-9]*' | head -1)
                                    dels=$(echo "$STATS" | grep -oE '[0-9]+ deletion' | grep -o '[0-9]*' | head -1)
                                    files=$(echo "$STATS" | grep -oE '[0-9]+ file' | grep -o '[0-9]*' | head -1)
                                    total_adds=$((total_adds + ${adds:-0}))
                                    total_dels=$((total_dels + ${dels:-0}))
                                    total_files=$((total_files + ${files:-0}))
                                    timeline_count=$((timeline_count + 1))
                                fi
                            fi
                        fi
                    fi
                done
                
                if [ "$timeline_count" -gt 0 ]; then
                    echo "  📊 $timeline_count timelines | $total_files files changed | +$total_adds -$total_dels lines"
                else
                    echo "  📊 No timelines found for this session"
                fi
                echo ""
            else
                # Display sessions with helpful info for multiple sessions
                echo "Multiple sessions found:"
                echo ""
                for i in "${!SESSION_LIST[@]}"; do
                    session_id="${SESSION_LIST[$i]}"
                    
                    # Display session number and stats
                    printf "  %2d) " "$i"
                    display_session_stats "$session_id" ""
                    
                    # Show timeline stats for this session
                    total_adds=0
                    total_dels=0
                    total_files=0
                    timeline_count=0
                    
                    for timeline in "${ALL_TIMELINES[@]}"; do
                        commit_hash=$(git rev-parse "$timeline" 2>/dev/null)
                        if [ -n "$commit_hash" ]; then
                            notes=$(git notes --ref=timeline show "$commit_hash" 2>/dev/null || true)
                            if [ -n "$notes" ]; then
                                sid=$(echo "$notes" | grep "^Session-Id:" | cut -d' ' -f2- | head -1)
                                if [ "$sid" = "$session_id" ] || [ -z "$sid" ]; then
                                    STATS=$(git diff --shortstat HEAD "$timeline" 2>/dev/null | sed 's/files\? changed/files/' || echo "")
                                    if [ -n "$STATS" ]; then
                                        adds=$(echo "$STATS" | grep -oE '[0-9]+ insertion' | grep -o '[0-9]*' | head -1)
                                        dels=$(echo "$STATS" | grep -oE '[0-9]+ deletion' | grep -o '[0-9]*' | head -1)
                                        files=$(echo "$STATS" | grep -oE '[0-9]+ file' | grep -o '[0-9]*' | head -1)
                                        total_adds=$((total_adds + ${adds:-0}))
                                        total_dels=$((total_dels + ${dels:-0}))
                                        total_files=$((total_files + ${files:-0}))
                                        timeline_count=$((timeline_count + 1))
                                    fi
                                fi
                            fi
                        fi
                    done
                    
                    if [ "$timeline_count" -gt 0 ]; then
                        printf "      📊 %d timelines | %d files changed | +%d -%d lines\n" "$timeline_count" "$total_files" "$total_adds" "$total_dels"
                    else
                        printf "      📊 No timelines found\n"
                    fi
                    echo ""
                done
                
                echo ""
                read -p "Select session number (or press Enter for session 0): " SESSION_CHOICE
                
                # Default to 0 if empty
                if [ -z "$SESSION_CHOICE" ]; then
                    SESSION_CHOICE=0
                fi
                
                # Validate choice
                if [ "$SESSION_CHOICE" -ge 0 ] && [ "$SESSION_CHOICE" -lt ${#SESSION_LIST[@]} ] 2>/dev/null; then
                    SELECTED_SESSION="${SESSION_LIST[$SESSION_CHOICE]}"
                    echo "Selected session: $SELECTED_SESSION"
                    echo ""
                else
                    echo "Invalid selection"
                    exit 1
                fi
            fi
            
            # Get timelines for selected session (include all, not just ones with changes)
            TIMELINES=()
            for timeline in "${ALL_TIMELINES[@]}"; do
                commit_hash=$(git rev-parse "$timeline" 2>/dev/null)
                if [ -n "$commit_hash" ]; then
                    notes=$(git notes --ref=timeline show "$commit_hash" 2>/dev/null || true)
                    if [ -n "$notes" ]; then
                        session_id=$(echo "$notes" | grep "^Session-Id:" | cut -d' ' -f2- | head -1)
                        if [ "$session_id" = "$SELECTED_SESSION" ]; then
                            TIMELINES+=("$timeline")
                        fi
                    fi
                fi
            done
            
            if [ ${#TIMELINES[@]} -eq 0 ]; then
                echo "No timelines found for session '$SELECTED_SESSION'"
                exit 0
            fi
            
            # Generate the conversation view content
            generate_view_content() {
                echo "📋 Conversation & Timeline View"
                echo "Session: $SELECTED_SESSION"
                echo "==============================================="
                echo "Found ${#TIMELINES[@]} timelines with changes"
                echo ""
                echo "💡 TIP: Use './timeline travel <commit-hash>' to restore any timeline"
                echo ""
                
                # Read the session JSONL file to get conversation flow
                SESSION_FILE=""
                for path in "$HOME/.claude/projects/-Users-steven-chong-Downloads-repos-timeline/${SELECTED_SESSION}.jsonl" \
                            "$HOME/.claude/projects/"*"/${SELECTED_SESSION}.jsonl"; do
                    if [ -f "$path" ]; then
                        SESSION_FILE="$path"
                        break
                    fi
                done
                
                if [ -f "$SESSION_FILE" ]; then
                    echo "📖 Reading conversation from session file..."
                    echo ""
                    
                    # Process conversation and interleave with timelines
                    MESSAGE_NUM=0
                    TIMELINE_INDEX=0
                    
                    while IFS= read -r line; do
                        # Parse JSON line - role is inside message object
                        role=$(echo "$line" | jq -r '.message.role // empty' 2>/dev/null)
                        
                        if [ "$role" = "user" ]; then
                            MESSAGE_NUM=$((MESSAGE_NUM + 1))
                            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                            echo "👤 User Message #$MESSAGE_NUM"
                            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                            
                            # Extract user message content
                            content=$(echo "$line" | jq -r '
                                if .message.content | type == "string" then 
                                    .message.content
                                elif .message.content | type == "array" then
                                    .message.content[0].text // empty
                                else
                                    empty
                                end' 2>/dev/null)
                            
                            if [ -n "$content" ]; then
                                # Show first 10 lines of user message
                                echo "$content" | head -10 | sed 's/^/  /'
                                line_count=$(echo "$content" | wc -l)
                                if [ "$line_count" -gt 10 ]; then
                                    echo "  ... ($(($line_count - 10)) more lines)"
                                fi
                            fi
                            echo ""
                            
                        elif [ "$role" = "assistant" ]; then
                            echo "🤖 Claude Response:"
                            echo "─────────────────────"
                            
                            # Extract assistant response (first part)
                            content=$(echo "$line" | jq -r '
                                if .message.content | type == "string" then 
                                    .message.content
                                elif .message.content | type == "array" then
                                    .message.content[0].text // empty
                                else
                                    empty
                                end' 2>/dev/null)
                            
                            if [ -n "$content" ]; then
                                # Show first 10 lines of assistant response
                                echo "$content" | head -10 | sed 's/^/  /'
                                line_count=$(echo "$content" | wc -l)
                                if [ "$line_count" -gt 10 ]; then
                                    echo "  ... ($(($line_count - 10)) more lines)"
                                fi
                            fi
                            
                            # Check if there's a corresponding timeline for this exchange
                            if [ $TIMELINE_INDEX -lt ${#TIMELINES[@]} ]; then
                                BRANCH="${TIMELINES[$TIMELINE_INDEX]}"
                                commit_hash=$(git rev-parse "$BRANCH" 2>/dev/null)
                                commit_time=$(git log -1 --pretty=format:"%ci" "$BRANCH" 2>/dev/null)
                                commit_msg=$(git log -1 --pretty=format:"%s" "$BRANCH" 2>/dev/null)
                                
                                echo ""
                                echo "  📍 Timeline Created: $commit_msg"
                                echo "  🕒 Time: $commit_time"
                                echo "  🔗 Restore: ./timeline travel $commit_hash"
                                
                                # Show file changes summary
                                echo "  📁 Changes:"
                                display_timeline_changes "$BRANCH" "HEAD" | sed 's/^/    /'
                                
                                TIMELINE_INDEX=$((TIMELINE_INDEX + 1))
                            fi
                            echo ""
                        fi
                    done < "$SESSION_FILE"
                    
                else
                    echo "⚠️  Could not find session file: $SELECTED_SESSION"
                    echo ""
                    
                    # Fall back to showing timelines without conversation context
                    for ((i=${#TIMELINES[@]}-1; i>=0; i--)); do
                        # Calculate display index (0 = oldest, higher = newer)
                        DISPLAY_INDEX=$((${#TIMELINES[@]} - 1 - i))
                        BRANCH="${TIMELINES[$i]}"
                        
                        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                        echo "📍 Timeline #$DISPLAY_INDEX"
                        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                        
                        # Get commit details
                        commit_hash=$(git rev-parse "$BRANCH" 2>/dev/null)
                        commit_time=$(git log -1 --pretty=format:"%ci" "$BRANCH" 2>/dev/null)
                        commit_msg=$(git log -1 --pretty=format:"%B" "$BRANCH" 2>/dev/null)
                        
                        echo "🕒 Time: $commit_time"
                        echo "🔗 Restore: ./timeline travel $commit_hash"
                        echo "📝 Commit Message:"
                        echo "$commit_msg" | sed 's/^/   /'
                        echo ""
                        
                        # Get conversation from git notes
                        notes=$(git notes --ref=timeline show "$commit_hash" 2>/dev/null || true)
                        
                        if [ -n "$notes" ]; then
                        # Extract conversation details from notes
                        user_request=$(echo "$notes" | grep "^User-Request-Full:" | cut -d' ' -f2- | head -1)
                        assistant_response=$(echo "$notes" | grep "^Assistant-Response-Full:" | cut -d' ' -f2- | head -1)
                        transcript_path=$(echo "$notes" | grep "^Transcript-Path:" | cut -d' ' -f2- | head -1)
                        parent_msg_id=$(echo "$notes" | grep "^Parent-Message-Id:" | cut -d' ' -f2- | head -1)
                        
                        # Show conversation
                        echo "💬 Conversation Context:"
                        echo "─────────────────────────"
                        
                        if [ -n "$user_request" ]; then
                            echo "👤 User Request:"
                            echo "$user_request" | sed 's/^/   /'
                            echo ""
                        fi
                        
                        if [ -n "$assistant_response" ]; then
                            echo "🤖 Claude Response:"
                            echo "$assistant_response" | sed 's/^/   /'
                            echo ""
                        fi
                        
                        # If no stored conversation, try to extract from transcript
                        if [ -z "$user_request" ] && [ -z "$assistant_response" ] && [ -n "$transcript_path" ] && [ -f "$transcript_path" ]; then
                            echo "📖 Extracting conversation from transcript..."
                            
                            # Get user request
                            full_user_request=$(get_full_user_request_from_jsonl "$transcript_path" "$parent_msg_id" 2>/dev/null)
                            if [ -n "$full_user_request" ]; then
                                echo "👤 User Request:"
                                echo "$full_user_request" | head -10 | sed 's/^/   /'
                                echo ""
                            fi
                            
                            # Get assistant response  
                            full_assistant_response=$(get_full_assistant_response_from_jsonl "$transcript_path" "$parent_msg_id" 2>/dev/null)
                            if [ -n "$full_assistant_response" ]; then
                                echo "🤖 Claude Response:"
                                echo "$full_assistant_response" | head -10 | sed 's/^/   /'
                                echo ""
                            fi
                        fi
                    fi
                    
                    # Show file changes with detailed breakdown
                    echo "📁 File Changes:"
                    echo "─────────────────"
                    display_timeline_changes "$BRANCH" "HEAD"
                    
                    echo ""
                    echo "🔍 Detailed File Diff:"
                    echo "─────────────────────"
                    
                    # Show actual file changes (first few lines)
                    CHANGED_FILES=$(git diff --name-only HEAD "$BRANCH" 2>/dev/null | head -5)
                    if [ -n "$CHANGED_FILES" ]; then
                        while IFS= read -r file; do
                            if [ -n "$file" ]; then
                                echo "   📄 $file:"
                                # Show first 5 lines of changes
                                DIFF=$(git diff HEAD "$BRANCH" -- "$file" 2>/dev/null | grep '^[+-]' | grep -v '^+++\|^---' | head -5)
                                if [ -n "$DIFF" ]; then
                                    echo "$DIFF" | sed 's/^/      /'
                                else
                                    echo "      (no visible diff content)"
                                fi
                                echo ""
                            fi
                        done <<< "$CHANGED_FILES"
                    fi
                    
                    echo ""
                    done
                fi
                
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo "📊 Session Summary"
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo "Session: $SELECTED_SESSION"
                echo "Total Timelines: ${#TIMELINES[@]}"
                if [ ${#TIMELINES[@]} -gt 0 ]; then
                    LAST_IDX=$((${#TIMELINES[@]} - 1))
                    echo "Time Range: $(git log -1 --pretty=format:"%ci" "${TIMELINES[$LAST_IDX]}" 2>/dev/null) to $(git log -1 --pretty=format:"%ci" "${TIMELINES[0]}" 2>/dev/null)"
                fi
                echo ""
                echo "This view shows the complete conversation flow and resulting code changes."
                echo "Each timeline represents a point where Claude made changes in response to user requests."
            }
            
            # Create temp file and open in editor
            TIMELINE_FILE=$(mktemp)
            generate_view_content > "$TIMELINE_FILE"
            
            # Determine which editor to use (respecting git config)
            EDITOR_CMD=""
            if [ -n "$GIT_EDITOR" ]; then
                EDITOR_CMD="$GIT_EDITOR"
            elif [ -n "$(git config --get core.editor 2>/dev/null)" ]; then
                EDITOR_CMD="$(git config --get core.editor)"
            elif [ -n "$VISUAL" ]; then
                EDITOR_CMD="$VISUAL"
            elif [ -n "$EDITOR" ]; then
                EDITOR_CMD="$EDITOR"
            elif command -v nano &> /dev/null; then
                EDITOR_CMD="nano"
            elif command -v vim &> /dev/null; then
                EDITOR_CMD="vim"
            elif command -v vi &> /dev/null; then
                EDITOR_CMD="vi"
            else
                EDITOR_CMD="less"
            fi
            
            # Open the timeline view
            $EDITOR_CMD "$TIMELINE_FILE"
            
            # Clean up
            rm -f "$TIMELINE_FILE"
            ;;
        "browse")
            # Browse files in a specific timeline
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null)
            
            # Get all timeline branches and filter out those identical to HEAD
            ALL_TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/*" 2>/dev/null))
            TIMELINES=()
            
            # Filter out timelines that are identical to HEAD
            for timeline in "${ALL_TIMELINES[@]}"; do
                if [ -n "$(git diff --name-only HEAD "$timeline" 2>/dev/null)" ]; then
                    TIMELINES+=("$timeline")
                fi
            done
            
            # Outer loop for timeline selection
            while true; do
                # Use the same display function as travel
                display_timeline "$CURRENT_BRANCH" "$CURRENT_HEAD"
                echo ""
                read -p "Select timeline number to browse (or press Enter to exit): " TIMELINE_NUM
                
                if [ -z "$TIMELINE_NUM" ]; then
                    echo "Exiting browse mode."
                    exit 0
                fi
                
                if [ "$TIMELINE_NUM" -lt 0 ] || [ "$TIMELINE_NUM" -ge "${#TIMELINES[@]}" ] 2>/dev/null; then
                    echo "Invalid selection. Please choose 0-$((${#TIMELINES[@]} - 1))"
                    echo ""
                    continue
                fi
                
                # Convert display index to array index
                # Display: 0=oldest, highest=newest
                # Array: 0=newest, highest=oldest
                ARRAY_INDEX=$((${#TIMELINES[@]} - 1 - TIMELINE_NUM))
                
                # Show files in selected timeline
                BRANCH="${TIMELINES[$ARRAY_INDEX]}"
                
                # Inner loop to allow viewing multiple files
                while true; do
                echo ""
                echo "Files different from current workspace in timeline $TIMELINE_NUM:"
                # Only show files that are different from HEAD and have actual diff content
                POTENTIAL_FILES=$(git diff --name-only HEAD "$BRANCH" 2>/dev/null)
                FILE_ARRAY=()
                
                if [ -n "$POTENTIAL_FILES" ]; then
                    # Double-check each file has actual diff content
                    while IFS= read -r file; do
                        if [ -n "$(git diff HEAD "$BRANCH" -- "$file" 2>/dev/null)" ]; then
                            FILE_ARRAY+=("$file")
                        fi
                    done <<< "$POTENTIAL_FILES"
                fi
                
                if [ ${#FILE_ARRAY[@]} -gt 0 ]; then
                    
                    # Display files with numbers
                    for idx in "${!FILE_ARRAY[@]}"; do
                        printf "  %2d) %s\n" "$((idx + 1))" "${FILE_ARRAY[$idx]}"
                    done
                    
                    echo ""
                    read -p "Select file number to view diff (or press Enter to go back): " FILE_NUM
                    
                    if [ -z "$FILE_NUM" ]; then
                        # Enter pressed - go back to timeline selection
                        break
                    elif [ "$FILE_NUM" -ge 1 ] && [ "$FILE_NUM" -le "${#FILE_ARRAY[@]}" ] 2>/dev/null; then
                        SELECTED_FILE="${FILE_ARRAY[$((FILE_NUM - 1))]}"
                        echo ""
                        echo "Diff for $SELECTED_FILE (compared to current workspace):"
                        echo "───────────────────────────────────────────────────────"
                        # Always compare against current HEAD to show what would change
                        # Use --color=always to force colors even in pipes
                        DIFF_OUTPUT=$(git diff --color=always HEAD "$BRANCH" -- "$SELECTED_FILE" 2>/dev/null)
                        
                        if [ -n "$DIFF_OUTPUT" ]; then
                            # Show the diff with colors and context
                            echo "$DIFF_OUTPUT"
                            echo "───────────────────────────────────────────────────────"
                            echo "Legend: $(tput setaf 1)- removed from current$(tput sgr0) | $(tput setaf 2)+ added in timeline$(tput sgr0)"
                        else
                            echo "  (no changes - file is identical to current workspace)"
                        fi
                        
                        # Wait for user to press Enter before showing file list again
                        echo ""
                        read -p "Press Enter to continue..."
                    else
                        echo "Invalid selection. Please choose 1-${#FILE_ARRAY[@]} or press Enter to go back."
                    fi
                else
                    echo "  (no files with differences)"
                    break
                fi
            done  # End inner loop (file selection)
            done  # End outer loop (timeline selection)
            ;;
        "search")
            # Search functionality
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null)
            
            # Check for pattern argument
            if [ -n "$2" ]; then
                # Pattern provided as argument
                PATTERN="$2"
            else
                # Direct search prompt
                read -p "🔍 Enter search query: " PATTERN
                if [ -z "$PATTERN" ]; then
                    echo "No search query provided."
                    exit 1
                fi
            fi
            
            # Default to searching both content and filenames
            SEARCH_CONTENT=true
            SEARCH_FILENAMES=true
            
            
            # Get all timeline branches sorted by date (newest first) and filter out those identical to HEAD
            ALL_TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/*" 2>/dev/null))
            TIMELINES=()
            
            # Filter out timelines that are identical to HEAD
            for timeline in "${ALL_TIMELINES[@]}"; do
                if [ -n "$(git diff --name-only HEAD "$timeline" 2>/dev/null)" ]; then
                    TIMELINES+=("$timeline")
                fi
            done
            
            # If still no timelines found, try a different approach
            if [ ${#TIMELINES[@]} -eq 0 ] && [ ${#ALL_TIMELINES[@]} -eq 0 ]; then
                ALL_TIMELINES=($(git branch --list "timelines/$CURRENT_BRANCH/*" 2>/dev/null | sed 's/^[* ]*//' | sort -r))
                for timeline in "${ALL_TIMELINES[@]}"; do
                    if [ -n "$(git diff --name-only HEAD "$timeline" 2>/dev/null)" ]; then
                        TIMELINES+=("$timeline")
                    fi
                done
            fi
            
            if [ ${#TIMELINES[@]} -eq 0 ]; then
                echo "No timeline timelines with changes found for branch '$CURRENT_BRANCH'"
                echo "Debug: Looking for timelines/$CURRENT_BRANCH/*"
                echo "Available timelines:"
                git branch --list "timelines/*" | head -5
                exit 0
            fi
            
            # Perform search
            echo "Searching for '$PATTERN' in ${#TIMELINES[@]} timelines..."
            echo ""
            
            FOUND_ANY=false
            SEARCH_TIMELINES=("${TIMELINES[@]}")
                
                # Search in selected timeline(s)
                for BRANCH in "${SEARCH_TIMELINES[@]}"; do
                # Get timeline index for display
                for idx in "${!TIMELINES[@]}"; do
                    if [ "${TIMELINES[$idx]}" = "$BRANCH" ]; then
                        # Display index is same as array index (0 = oldest)
                        TIMELINE_INDEX=$idx
                        break
                    fi
                done
                
                # Get timeline info
                SUBJECT=$(git log -1 --pretty=format:"%s" "$BRANCH" 2>/dev/null)
                timeline_info=$(echo "$SUBJECT" | sed 's/ - [0-9]* files$//')
                
                # Search based on user selection
                CONTENT_MATCHES=""
                FILENAME_MATCHES=""
                CHANGED_MATCHES=""
                
                if [ "$SEARCH_CONTENT" = true ]; then
                    # Only search in files that are different from HEAD
                    CHANGED_FILES=$(git diff --name-only HEAD "$BRANCH" 2>/dev/null)
                    if [ -n "$CHANGED_FILES" ]; then
                        CONTENT_MATCHES=""
                        while IFS= read -r file; do
                            # Check if this file contains the pattern
                            if git grep -q "$PATTERN" "$BRANCH" -- "$file" 2>/dev/null; then
                                CONTENT_MATCHES="${CONTENT_MATCHES}${file}"$'\n'
                            fi
                        done <<< "$CHANGED_FILES"
                    fi
                fi
                
                if [ "$SEARCH_FILENAMES" = true ]; then
                    # Only search in files that are different from HEAD
                    FILENAME_MATCHES=$(git diff --name-only HEAD "$BRANCH" 2>/dev/null | grep -i "$PATTERN" 2>/dev/null || echo "")
                fi
                
                if [ "$SEARCH_CHANGED_ONLY" = true ]; then
                    # Search only in changed lines (additions and deletions)
                    DIFF_OUTPUT=$(git diff HEAD "$BRANCH" 2>/dev/null | grep -E "^[+-].*$PATTERN" | grep -v '^+++\|^---' || true)
                    if [ -n "$DIFF_OUTPUT" ]; then
                        CHANGED_MATCHES="$DIFF_OUTPUT"
                    fi
                fi
                
                # Display results if any matches found
                if [ -n "$CONTENT_MATCHES" ] || [ -n "$FILENAME_MATCHES" ] || [ -n "$CHANGED_MATCHES" ]; then
                    if [ "$FOUND_ANY" = false ]; then
                        FOUND_ANY=true
                    fi
                    
                    echo "📍 $timeline_info"
                    
                    if [ -n "$CHANGED_MATCHES" ]; then
                        echo "   Changed lines matching '$PATTERN':"
                        echo "$CHANGED_MATCHES" | head -20 | while IFS= read -r line; do
                            echo "      $line"
                        done
                    fi
                    
                    if [ -n "$CONTENT_MATCHES" ]; then
                        echo "   Content matches:"
                        while IFS= read -r file; do
                            if [ -n "$file" ]; then
                                echo "      📄 $file:"
                                # Show all matching lines in this file
                                git grep -n "$PATTERN" "$BRANCH" -- "$file" 2>/dev/null | while IFS= read -r match; do
                                    # Extract line number and match content
                                    LINE_INFO=$(echo "$match" | sed "s|^$BRANCH:$file:||")
                                    # Format as "line 123: content"
                                    LINE_NUM=$(echo "$LINE_INFO" | cut -d: -f1)
                                    LINE_CONTENT=$(echo "$LINE_INFO" | cut -d: -f2-)
                                    echo "         line $LINE_NUM: $LINE_CONTENT" | cut -c1-80
                                done | head -5  # Limit to 5 matches per file
                            fi
                        done <<< "$CONTENT_MATCHES"
                    fi
                    
                    if [ -n "$FILENAME_MATCHES" ]; then
                        echo "   Filename matches:"
                        while IFS= read -r file; do
                            if [ -n "$file" ]; then
                                echo "      $file"
                            fi
                        done <<< "$FILENAME_MATCHES"
                    fi
                    
                    echo ""
                fi
            done
            
            if [ "$FOUND_ANY" = false ]; then
                echo "No matches found for '$PATTERN' in any timeline"
            else
                echo "💡 Use 'timeline travel' to go to a specific timeline"
            fi
            
            exit 0
            ;;
        "travel")
            # Check if a commit hash was provided as argument
            if [ $# -eq 2 ] && [ -n "$2" ]; then
                # Direct travel to specific commit
                COMMIT_HASH="$2"
                
                # Validate it's a valid commit
                if ! git rev-parse --verify "$COMMIT_HASH" >/dev/null 2>&1; then
                    echo "❌ Invalid commit hash: $COMMIT_HASH"
                    exit 1
                fi
                
                echo "🚀 Traveling directly to commit: $COMMIT_HASH"
                echo ""
                
                # Create backup timeline before making changes
                CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
                BACKUP_MSG="Backup before travel to $COMMIT_HASH"
                ./timeline save >/dev/null 2>&1
                
                # Restore to the specified commit
                echo "📍 Restoring working directory to commit $COMMIT_HASH..."
                git restore --source="$COMMIT_HASH" --worktree . 2>/dev/null || {
                    # Fallback for older git versions
                    git checkout "$COMMIT_HASH" -- . 2>/dev/null
                }
                
                echo "✅ Successfully traveled to commit $COMMIT_HASH"
                echo ""
                echo "To return to your previous state, use: ./timeline travel"
                exit 0
            fi
            
            # Get current branch name
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null || exit 0)
            
            # Outer loop for timeline selection
            while true; do
                # Display timeline using shared function
                if ! display_timeline "$CURRENT_BRANCH" "$CURRENT_HEAD"; then
                    exit 0
                fi
                
                echo ""
                
                # Always prompt for selection (no arguments provided)
                read -p "Select timeline number to travel to (0-$((${#TIMELINES[@]} - 1)), or press Enter to exit): " SELECTION
                
                # Handle quit - accept empty input
                if [ -z "$SELECTION" ]; then
                    echo "Exiting travel mode."
                    exit 0
                fi
                
                # Check if argument is a number (timeline) or commit ID
                if [[ "$SELECTION" =~ ^[0-9]+$ ]]; then
                    # Validate number is in range
                    if [ "$SELECTION" -lt 0 ] || [ "$SELECTION" -ge ${#TIMELINES[@]} ]; then
                        echo "Invalid selection. Please choose 0-$((${#TIMELINES[@]} - 1))"
                        echo ""
                        continue
                    fi
                    
                    # Convert display index to array index
                    # Display: 0=oldest, highest=newest
                    # Array: 0=newest, highest=oldest  
                    ARRAY_INDEX=$((${#TIMELINES[@]} - 1 - SELECTION))
                    TIMELINE_BRANCH="${TIMELINES[$ARRAY_INDEX]}"
                
                # Show preview of what will change
                echo ""
                echo "📋 Preview of changes when traveling to this timeline:"
                echo "───────────────────────────────────────────────────────"
                
                # Use shared function to display changes
                display_timeline_changes "$TIMELINE_BRANCH" "HEAD"
                
                # Show summary stats
                STATS=$(git diff --shortstat HEAD "$TIMELINE_BRANCH" 2>/dev/null)
                if [ -n "$STATS" ]; then
                    echo ""
                    echo "   Summary: $STATS"
                fi
                echo "───────────────────────────────────────────────────────"
                
                # Get the timeline commit SHA
                TIMELINE_SHA=$(git rev-parse "$TIMELINE_BRANCH")
                
                # Inner loop for confirmation
                while true; do
                    # Option 1: Full restore - completely replace working directory with timeline
                    # This is destructive but exact
                    echo ""
                    read -p "⚠️  Travel to this timeline? (y to confirm, Enter to go back): " -n 1 -r
                    echo
                    
                    if [ -z "$REPLY" ]; then
                        # Enter pressed - go back to timeline selection
                        echo ""
                        break
                    elif [[ $REPLY =~ ^[Yy]$ ]]; then
                    # Check if there are any changes to backup
                    if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
                        # Save current work as a backup timeline first
                        echo "📸 Creating backup timeline before time travel..."
                        BACKUP_TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
                        BACKUP_MSG="timeline-backup: before-travel@$BACKUP_TIMESTAMP"
                        
                        # Create backup using same plumbing approach
                        export GIT_INDEX_FILE=$(mktemp)
                        git read-tree HEAD >/dev/null 2>&1
                        git add --all >/dev/null 2>&1
                        BACKUP_TREE=$(git write-tree)
                        BACKUP_COMMIT=$(echo "$BACKUP_MSG" | git commit-tree $BACKUP_TREE -p HEAD)
                        git update-ref "refs/heads/timelines/$CURRENT_BRANCH/backup-$BACKUP_TIMESTAMP" $BACKUP_COMMIT >/dev/null 2>&1
                        rm -f $GIT_INDEX_FILE
                        unset GIT_INDEX_FILE
                        
                        echo "✅ Backup created: timelines/$CURRENT_BRANCH/backup-$BACKUP_TIMESTAMP"
                    else
                        echo "ℹ️  No changes to backup (working directory is clean)"
                    fi
                    
                    # Now restore from timeline to working directory only (preserve staging area)
                    # Use git restore with --worktree flag (Git 2.23+) or fallback to checkout
                    if git restore --help >/dev/null 2>&1; then
                        # Modern git with restore command
                        git restore --source="$TIMELINE_BRANCH" --worktree . >/dev/null 2>&1
                    else
                        # Fallback: checkout to temp location and copy
                        TEMP_DIR=$(mktemp -d)
                        git --work-tree="$TEMP_DIR" checkout "$TIMELINE_BRANCH" -- . >/dev/null 2>&1
                        cp -r "$TEMP_DIR"/* . 2>/dev/null || true
                        rm -rf "$TEMP_DIR"
                    fi
                    
                    echo "✅ Traveled to timeline #$SELECTION (unstaged changes)"
                    echo "💡 Your staged changes are preserved"
                    echo "💡 Use 'git status' to see all changes"
                    echo "💡 Use 'timeline travel' to see backup timeline"
                    
                    # Exit after successful travel
                    exit 0
                    else
                        # User didn't confirm
                        echo "Travel cancelled."
                        break
                    fi
                done  # End inner confirmation loop
                
            else
                # Handle commit travel by commit ID
                if ! git rev-parse --verify "$SELECTION" >/dev/null 2>&1; then
                    echo "Error: '$SELECTION' is not a valid timeline number or commit ID"
                    exit 1
                fi
                
                echo "🔄 Traveling to commit: $SELECTION"
                
                # Confirm before resetting to commit
                read -p "This will reset your working directory to commit $SELECTION. Continue? (y/N): " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    echo "Cancelled."
                    exit 0
                fi
                
                git reset --hard "$SELECTION"
                echo "✅ Reset to commit $SELECTION"
                echo "💡 Use 'git status' to see the current state"
                exit 0
            fi
            done  # End outer while loop for timeline selection
            ;;
        *)
            echo "Usage:"
            echo "  timeline save             - Create a timeline manually"
            echo "  timeline travel           - Show timelines and travel interactively"
            echo "  timeline view             - Quick view all timelines with changes"
            echo "  timeline browse           - Browse files in a specific timeline"
            echo "  timeline search [pattern] - Search for text across timelines"
            echo "  timeline delete           - Delete timelines interactively"
            echo "  timeline cleanup          - Clean up timelines for deleted branches"
            echo "  timeline install          - Install hook to Claude Code"
            echo "  timeline uninstall        - Remove hook from Claude Code"
            exit 1
            ;;
    esac
else
    # No arguments - show help
    echo "Usage:"
    echo "  timeline save             - Create a timeline manually"
    echo "  timeline travel           - Show timelines and travel interactively"
    echo "  timeline view             - Quick view all timelines with changes"
    echo "  timeline browse           - Browse files in a specific timeline"
    echo "  timeline search [pattern] - Search for text across timelines"
    echo "  timeline delete           - Delete timelines interactively"
    echo "  timeline cleanup          - Clean up timelines for deleted branches"
    echo "  timeline install          - Install hook to Claude Code"
    echo "  timeline uninstall        - Remove hook from Claude Code"
    exit 0
fi

# Check if we're in a git repo first
if ! git rev-parse --git-dir >/dev/null 2>&1; then
    # Not a git repo, exit silently
    exit 0
fi

# Get current branch and last timeline
CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
LAST_TIMELINE=$(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-' | head -1)

# Always check against last timeline if it exists
if [ -n "$LAST_TIMELINE" ]; then
    # Create a temporary index for the last timeline to compare untracked files
    export GIT_INDEX_FILE=$(mktemp)
    git read-tree "$LAST_TIMELINE" >/dev/null 2>&1
    LAST_TREE=$(git write-tree 2>/dev/null)
    rm -f $GIT_INDEX_FILE
    unset GIT_INDEX_FILE
    
    # Create a temporary index for current state
    export GIT_INDEX_FILE=$(mktemp)
    git read-tree HEAD >/dev/null 2>&1
    git add --all >/dev/null 2>&1
    CURRENT_TREE=$(git write-tree 2>/dev/null)
    rm -f $GIT_INDEX_FILE
    unset GIT_INDEX_FILE
    
    # If the trees are identical, no changes since last timeline
    if [ "$LAST_TREE" = "$CURRENT_TREE" ]; then
        # No changes since last timeline, exit silently
        exit 0
    fi
else
    # No previous timeline exists, check if there are any changes from HEAD
    if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null || [ -n "$(git ls-files --others --exclude-standard 2>/dev/null)" ]; then
        # Changes exist, continue to create timeline
        :
    else
        # No changes from HEAD and no previous timeline, exit silently
        exit 0
    fi
fi

# Get current branch name and working directory info
CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null) || exit 0
SHORT_HEAD=$(git rev-parse --short HEAD)

# Get the commit message of current HEAD
COMMIT_MSG=$(git log -1 --pretty=format:"%s" HEAD)

# Find the next timeline number for this base commit
TIMELINE_NUM=0
EXISTING_TIMELINES=$(git branch --list "timelines/$CURRENT_BRANCH/+*" 2>/dev/null | sed 's/^[\* ]*//')
if [ -n "$EXISTING_TIMELINES" ]; then
    # Look for timelines with same base commit
    for branch in $EXISTING_TIMELINES; do
        # Check if this timeline is based on current HEAD
        if git log -1 --pretty=format:"%s" "$branch" 2>/dev/null | grep -q "@$SHORT_HEAD"; then
            # Extract the number from branch name like "+0", "+1", etc
            num=$(echo "$branch" | sed -n "s|timelines/$CURRENT_BRANCH/+\([0-9]*\).*|\1|p")
            if [ -n "$num" ] && [ "$num" -ge "$TIMELINE_NUM" ]; then
                TIMELINE_NUM=$((num + 1))
            fi
        fi
    done
fi

# Create timeline branch name with +N format and commit message
# Clean commit message to be branch-safe (remove special chars)
SAFE_MSG=$(echo "$COMMIT_MSG" | sed 's/[^a-zA-Z0-9._-]/_/g' | cut -c1-50)
TIMELINE_BRANCH="timelines/$CURRENT_BRANCH/+${TIMELINE_NUM}_${SAFE_MSG}"

# Create timeline using git plumbing commands (zero working directory impact)
# This creates a real git commit without touching the working directory or index

# Step 1: Create a temporary index to work with (doesn't affect the real index)
export GIT_INDEX_FILE=$(mktemp)
trap "rm -f $GIT_INDEX_FILE" EXIT

# Step 2: Read current HEAD into our temporary index
git read-tree HEAD >/dev/null 2>&1

# Step 3: Update temporary index with current working tree state
# This captures both staged and unstaged changes in their final form
git add --all >/dev/null 2>&1

# Step 4: Write the tree object from our temporary index
TREE_SHA=$(git write-tree)

# Step 5: Generate detailed file breakdown for commit message
file_status=$(git diff --name-status HEAD $TREE_SHA 2>/dev/null)
TIMELINE_MSG=""

if [ -n "$file_status" ]; then
    # Get file counts for summary line
    added_files=$(echo "$file_status" | grep '^A' | wc -l | tr -d ' ')
    modified_files=$(echo "$file_status" | grep '^M' | wc -l | tr -d ' ')
    removed_files=$(echo "$file_status" | grep '^D' | wc -l | tr -d ' ')
    
    # Get line stats
    STATS=$(git diff --shortstat HEAD $TREE_SHA 2>/dev/null | sed 's/files\? changed/files/' || echo "")
    ADDS=$(echo "$STATS" | grep -oE '[0-9]+ insertion' | grep -o '[0-9]*' | head -1)
    DELS=$(echo "$STATS" | grep -oE '[0-9]+ deletion' | grep -o '[0-9]*' | head -1)
    ADDS=${ADDS:-0}
    DELS=${DELS:-0}
    
    # Use shared function to generate summary line
    TIMELINE_MSG=$(generate_summary_line "$added_files" "$modified_files" "$removed_files" "$ADDS" "$DELS")
    
    # Add individual file lines (sorted by impact then alphabetically)
    # Create temp file for sorting
    temp_file=$(mktemp)
    
    while IFS= read -r line; do
        if [ -n "$line" ]; then
            status=$(echo "$line" | cut -f1)
            filename=$(echo "$line" | cut -f2-)
            
            # Get line changes for this file
            file_stats=$(git diff --stat HEAD $TREE_SHA -- "$filename" 2>/dev/null | tail -1)
            file_adds=$(echo "$file_stats" | grep -oE '[0-9]+ \+' | grep -o '[0-9]*' || echo "0")
            file_dels=$(echo "$file_stats" | grep -oE '[0-9]+ -' | grep -o '[0-9]*' || echo "0")
            file_adds=${file_adds:-0}
            file_dels=${file_dels:-0}
            
            # Create visual for this file
            file_visual=""
            if [ "$file_adds" -gt 0 ]; then
                if [ "$file_adds" -lt 10 ]; then
                    file_visual="${file_visual}$(printf -- '+%.0s' $(seq 1 $file_adds))"
                else
                    file_visual="${file_visual}+++"
                fi
            fi
            if [ "$file_dels" -gt 0 ]; then
                if [ "$file_dels" -lt 10 ]; then
                    file_visual="${file_visual}$(printf -- '-%.0s' $(seq 1 $file_dels))"
                else
                    file_visual="${file_visual}---"
                fi
            fi
            
            # Convert status to symbol
            case "$status" in
                A) symbol="+" ;;
                M) symbol="~" ;;
                D) symbol="-" ;;
                *) symbol="?" ;;
            esac
            
            # Calculate impact for sorting (total lines changed)
            impact=$((file_adds + file_dels))
            
            # Store for sorting: impact:filename:symbol:visual:adds:dels
            printf "%05d:%s:%s:%s:%s:%s\n" "$impact" "$filename" "$symbol" "$file_visual" "$file_adds" "$file_dels" >> "$temp_file"
        fi
    done <<< "$file_status"
    
    # Sort by impact (descending) then filename (ascending) and build message
    if [ -f "$temp_file" ]; then
        # Read sorted file into TIMELINE_MSG
        while IFS=: read -r impact filename symbol file_visual file_adds file_dels; do
            TIMELINE_MSG="${TIMELINE_MSG}
${symbol}${filename} ${file_visual} +${file_adds} -${file_dels} lines"
        done < <(sort -rn -t: -k1,1 -k2,2 "$temp_file")
        rm -f "$temp_file"
    fi
else
    TIMELINE_MSG="No changes"
fi

# Step 6: Create the commit object (without updating any refs yet)
TIMELINE_COMMIT=$(echo "$TIMELINE_MSG" | git commit-tree $TREE_SHA -p $CURRENT_HEAD)

# Step 7: Create a branch reference for this timeline
git update-ref "refs/heads/$TIMELINE_BRANCH" $TIMELINE_COMMIT >/dev/null 2>&1

# Step 8: Add git notes with session information
CURRENT_SESSION=$(get_current_claude_session)
if [ -n "$CURRENT_SESSION" ]; then
    # Add the note to the timeline commit using -m flag (stdin doesn't work properly)
    git notes --ref=timeline add -m "Session-Id: $CURRENT_SESSION" "$TIMELINE_COMMIT" 2>/dev/null || true
fi

# Clean up temp index
rm -f $GIT_INDEX_FILE
unset GIT_INDEX_FILE

# Silent completion - no output needed since this runs automatically via hooks