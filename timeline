#!/bin/bash

# Timeline - git-based timeline utility for tracking file changes
# Usage: 
#   - Called automatically by Claude Code after tool use (no args)
#   - timeline list             - List all timelines
#   - timeline travel <number>    - Travel to a specific timeline by number
#   - timeline travel <commit-id> - Travel to a specific git commit
#   - timeline install          - Install hook to Claude Code
#   - timeline uninstall        - Remove hook from Claude Code

set -e

# Auto-detect script location
SCRIPT_PATH="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"

# Shared function to display file changes for a timeline
display_timeline_changes() {
    local BRANCH="$1"
    local COMPARE_REF="${2:-HEAD}"  # Default to HEAD if not specified
    
    # Show files that changed with preview
    echo "   Files that changed (with preview):"
    CHANGED_FILES=$(git diff --name-only "$COMPARE_REF" "$BRANCH" 2>/dev/null | head -10)
    if [ -n "$CHANGED_FILES" ]; then
        while IFS= read -r file; do
            if [ -n "$file" ]; then
                echo "      üìÑ $file"
                # Show first 3 lines of changes
                DIFF=$(git diff "$COMPARE_REF" "$BRANCH" -- "$file" 2>/dev/null | grep '^[+-]' | grep -v '^+++\|^---' | head -3)
                if [ -n "$DIFF" ]; then
                    echo "$DIFF" | while IFS= read -r line; do
                        echo "         $line"
                    done
                fi
            fi
        done <<< "$CHANGED_FILES"
    fi
}

# Shared function to display timeline entries
display_timeline() {
    local CURRENT_BRANCH="$1"
    local CURRENT_HEAD="$2"
    
    echo "‚è∞ Timeline for branch '$CURRENT_BRANCH':"
    echo ""
    
    # Get all timeline entries sorted by date (newest first), excluding backups
    ALL_TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-' | head -20))
    TIMELINES=()
    
    # Filter out timelines that are identical to HEAD
    for timeline in "${ALL_TIMELINES[@]}"; do
        if [ -n "$(git diff --name-only HEAD "$timeline" 2>/dev/null)" ]; then
            TIMELINES+=("$timeline")
        fi
    done
    
    if [ ${#TIMELINES[@]} -eq 0 ]; then
        echo "No timeline entries found for branch '$CURRENT_BRANCH'"
        return 1
    fi
    
    # Process each timeline (oldest first, newest last)
    # Note: TIMELINES array is sorted newest first, so we need to iterate in reverse
    for ((i=${#TIMELINES[@]}-1; i>=0; i--)); do
        # Calculate display index (0 = oldest, higher = newer)
        DISPLAY_INDEX=$((${#TIMELINES[@]} - 1 - i))
        BRANCH="${TIMELINES[$i]}"
        
        # Get timeline commit message
        SUBJECT=$(git log -1 --pretty=format:"%s" "$BRANCH" 2>/dev/null)
        timeline_info=$(echo "$SUBJECT" | sed 's/ - [0-9]* files$//')
        
        # Always compare against current HEAD to show what would change if you travel to this timeline
        STATS=$(git diff --shortstat HEAD "$BRANCH" 2>/dev/null | sed 's/files\? changed/files/' || echo "")
        
        # Format line
        printf "  %2d: %s\n" "$DISPLAY_INDEX" "$timeline_info"
        
        # Show visual diff on next line if there are changes
        if [ -n "$STATS" ]; then
            # Parse stats (handle both singular and plural forms)
            FILES=$(echo "$STATS" | grep -oE '[0-9]+ file' | grep -o '[0-9]*' | head -1)
            ADDS=$(echo "$STATS" | grep -oE '[0-9]+ insertion' | grep -o '[0-9]*' | head -1)
            DELS=$(echo "$STATS" | grep -oE '[0-9]+ deletion' | grep -o '[0-9]*' | head -1)
            
            # Default to 0 if empty
            FILES=${FILES:-0}
            ADDS=${ADDS:-0}
            DELS=${DELS:-0}
            
            # Create visual indicator
            VISUAL=""
            if [ "$ADDS" -gt 0 ]; then
                if [ "$ADDS" -lt 10 ]; then
                    VISUAL="${VISUAL}$(printf -- '+%.0s' $(seq 1 $ADDS))"
                elif [ "$ADDS" -lt 50 ]; then
                    VISUAL="${VISUAL}+++"
                elif [ "$ADDS" -lt 100 ]; then
                    VISUAL="${VISUAL}+++++"
                else
                    VISUAL="${VISUAL}+++++++"
                fi
            fi
            
            if [ "$DELS" -gt 0 ]; then
                if [ "$DELS" -lt 10 ]; then
                    VISUAL="${VISUAL}$(printf -- '-%.0s' $(seq 1 $DELS))"
                elif [ "$DELS" -lt 50 ]; then
                    VISUAL="${VISUAL}---"
                elif [ "$DELS" -lt 100 ]; then
                    VISUAL="${VISUAL}-----"
                else
                    VISUAL="${VISUAL}-------"
                fi
            fi
            
            # Show visual indicator and formatted stats (GitHub-style)
            printf "      %s  %d files, +%d lines, -%d lines\n" "$VISUAL" "$FILES" "$ADDS" "$DELS"
        else
            printf "      (no changes)\n"
        fi
    done
    
    return 0
}

# Handle command line arguments
if [ $# -gt 0 ]; then
    case "$1" in
        "save")
            # Explicit timeline creation - continue to timeline logic below
            ;;
        "install")
            # Use environment variable if set, otherwise default to ~/.claude
            CLAUDE_DIR="${CLAUDE_CONFIG_DIR:-$HOME/.claude}"
            SETTINGS_FILE="$CLAUDE_DIR/settings.json"
            
            echo "üöÄ Timeline Hook Installer"
            echo "========================="
            echo ""
            
            if [ ! -f "$SETTINGS_FILE" ]; then
                echo "‚ùå Claude Code settings file not found at: $SETTINGS_FILE"
                echo "Please make sure Claude Code is installed and configured."
                exit 1
            fi
            
            # Check if already installed (check for script path patterns)
            if grep -q "timeline" "$SETTINGS_FILE"; then
                echo "‚úÖ Timeline hook is already installed in Claude Code settings"
                echo "Current hook references in settings.json:"
                grep -n "timeline" "$SETTINGS_FILE" | head -3
                exit 0
            fi
            
            # Create backup
            cp "$SETTINGS_FILE" "$SETTINGS_FILE.backup"
            echo "üìã Backed up settings to: $SETTINGS_FILE.backup"
            
            # Install hook using jq (similar to claude-lsp-cli installer)
            if command -v jq &> /dev/null; then
                # Add to BOTH PreToolUse and PostToolUse hooks
                # PreToolUse catches state before destructive commands (git checkout, etc)
                # PostToolUse catches state after file edits
                
                # First, add to PostToolUse
                jq --arg cmd "$SCRIPT_PATH save" '.hooks.PostToolUse = ((.hooks.PostToolUse // []) | 
                    if length > 0 and .[0].hooks then
                        if (.[0].hooks | map(.command) | any(contains("timeline"))) then
                            .
                        else
                            .[0].hooks += [{"type": "command", "command": $cmd}]
                        end
                    else
                        . + [{"hooks": [{"type": "command", "command": $cmd}]}]
                    end)' "$SETTINGS_FILE.backup" > "$SETTINGS_FILE.tmp"
                
                # Then, add to PreToolUse (for Bash commands that might destroy changes)
                jq --arg cmd "$SCRIPT_PATH save" '.hooks.PreToolUse = ((.hooks.PreToolUse // []) | 
                    if length > 0 then
                        # Look for Bash matcher
                        map(if .matcher == "Bash" then
                            if (.hooks | map(.command) | any(contains("timeline"))) then
                                .
                            else
                                .hooks += [{"type": "command", "command": $cmd}]
                            end
                        else
                            .
                        end)
                    else
                        # Create new PreToolUse with Bash matcher
                        . + [{"matcher": "Bash", "hooks": [{"type": "command", "command": $cmd}]}]
                    end)' "$SETTINGS_FILE.tmp" > "$SETTINGS_FILE"
                
                rm -f "$SETTINGS_FILE.backup" "$SETTINGS_FILE.tmp"
                echo "‚úÖ Installed timeline hooks to settings.json (Pre and Post)"
            else
                echo "‚ö†Ô∏è  jq not found - please manually add hook to settings.json:"
                echo "  Add to PostToolUse hooks array: {\"type\": \"command\", \"command\": \"$SCRIPT_PATH save\"}"
                echo ""
                echo "Install jq for automatic hook management:"
                echo "  brew install jq  # macOS"
                echo "  apt install jq   # Ubuntu/Debian"
                exit 1
            fi
            
            echo ""
            echo "üéâ Timeline hook installation complete!"
            echo "The hook will now automatically create timeline timelines after any Claude Code tool use."
            echo ""
            echo "Available commands:"
            echo "  timeline travel           - Show and travel to timelines"
            echo "  timeline delete           - Delete timelines"
            echo "  timeline cleanup          - Clean up timelines for deleted branches"
            echo "  timeline uninstall        - Remove the hook"
            echo ""
            echo "Timeline timelines will be stored in: timelines/<branch-name>/"
            exit 0
            ;;
        "uninstall")
            # Use environment variable if set, otherwise default to ~/.claude
            CLAUDE_DIR="${CLAUDE_CONFIG_DIR:-$HOME/.claude}"
            SETTINGS_FILE="$CLAUDE_DIR/settings.json"
            
            echo "üóëÔ∏è  Timeline Hook Uninstaller"
            echo "============================="
            echo ""
            
            if [ ! -f "$SETTINGS_FILE" ]; then
                echo "‚ùå Claude Code settings file not found at: $SETTINGS_FILE"
                exit 1
            fi
            
            # Check if hook is installed (check for any timeline references)
            if ! grep -q "timeline" "$SETTINGS_FILE"; then
                echo "‚úÖ Timeline hook is not currently installed"
                exit 0
            fi
            
            echo "Current hook references found:"
            grep -n "timeline" "$SETTINGS_FILE" | head -3
            
            # Create backup
            cp "$SETTINGS_FILE" "$SETTINGS_FILE.backup"
            echo "üìã Backed up settings to: $SETTINGS_FILE.backup"
            
            # Remove hook using jq (similar to claude-lsp-cli installer logic)
            if command -v jq &> /dev/null; then
                # Remove timeline hooks from both PostToolUse and PreToolUse
                jq '.hooks.PostToolUse = ((.hooks.PostToolUse // []) | 
                    map(.hooks = (.hooks | map(select(.command | test("timeline") | not)))))' "$SETTINGS_FILE.backup" > "$SETTINGS_FILE.tmp"
                
                # Also remove from PreToolUse
                jq '.hooks.PreToolUse = ((.hooks.PreToolUse // []) | 
                    map(if .hooks then 
                        .hooks = (.hooks | map(select(.command | test("timeline") | not)))
                    else 
                        . 
                    end))' "$SETTINGS_FILE.tmp" > "$SETTINGS_FILE"
                
                rm -f "$SETTINGS_FILE.backup" "$SETTINGS_FILE.tmp"
                echo "‚úÖ Timeline hooks removed from settings.json (Pre and Post)"
            else
                echo "‚ö†Ô∏è  jq not found - please manually remove hook from settings.json"
                echo "Look for: {\"type\": \"command\", \"command\": \"$SCRIPT_PATH save\"}"
                exit 1
            fi
            
            echo ""
            echo "üóëÔ∏è  Timeline hook uninstallation complete!"
            echo "The hook will no longer run automatically with Claude Code."
            echo "Your existing timeline timelines are preserved in the timelines/ directories."
            echo ""
            echo "To reinstall: timeline install"
            exit 0
            ;;
        "delete")
            # Interactive delete with options
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null || exit 0)
            
            # Display timeline using shared function
            echo "üóëÔ∏è  Delete Timelines"
            echo "===================="
            if ! display_timeline "$CURRENT_BRANCH" "$CURRENT_HEAD"; then
                exit 0
            fi
            
            # Get timeline count for options
            TIMELINE_COUNT=$(git for-each-ref --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-' | wc -l | tr -d ' ')
            
            echo ""
            echo "Options:"
            echo "  a) Delete all timelines"
            echo "  0-$((TIMELINE_COUNT-1))) Delete specific timeline by number"
            echo "  x-y) Delete range of timelines (e.g., 0-11)"
            echo ""
            
            while true; do
                read -p "Select option (or press Enter to cancel): " choice
                
                # Handle cancel - empty input or quit commands
                if [ -z "$choice" ] || [ "$choice" = "q" ] || [ "$choice" = "Q" ] || [ "$choice" = "quit" ] || [ "$choice" = "exit" ] || [ "$choice" = "cancel" ]; then
                    echo "Cancelled."
                    exit 0
                fi
                
                case "$choice" in
                    "a"|"A")
                        echo ""
                        echo "‚ö†Ô∏è  This will permanently delete ALL $TIMELINE_COUNT timelines."
                        read -p "Are you sure? (y/N): " -n 1 -r
                        echo
                        if [[ $REPLY =~ ^[Yy]$ ]]; then
                            git for-each-ref --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" | grep -v '/backup-' | \
                                xargs -I {} git branch -D {} >/dev/null 2>&1
                            echo "‚úÖ Deleted $TIMELINE_COUNT timelines"
                        else
                            echo "Cancelled."
                        fi
                        exit 0
                        ;;
                    *)
                        # Check for range (e.g., 0-11)
                        if [[ "$choice" =~ ^([0-9]+)-([0-9]+)$ ]]; then
                            START="${BASH_REMATCH[1]}"
                            END="${BASH_REMATCH[2]}"
                            
                            # Validate range
                            if [ "$START" -ge 0 ] && [ "$END" -lt "$TIMELINE_COUNT" ] && [ "$START" -le "$END" ]; then
                                RANGE_COUNT=$((END - START + 1))
                                echo ""
                                echo "‚ö†Ô∏è  This will delete $RANGE_COUNT timelines (from #$START to #$END)"
                                read -p "Are you sure? (y/N): " -n 1 -r
                                echo
                                if [[ $REPLY =~ ^[Yy]$ ]]; then
                                    # Get all timeline branches in order
                                    TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-'))
                                    
                                    # Delete the range (convert display indices to array indices)
                                    for i in $(seq $START $END); do
                                        ARRAY_INDEX=$((${#TIMELINES[@]} - 1 - i))
                                        if [ $ARRAY_INDEX -ge 0 ] && [ $ARRAY_INDEX -lt ${#TIMELINES[@]} ]; then
                                            git branch -D "${TIMELINES[$ARRAY_INDEX]}" >/dev/null 2>&1
                                        fi
                                    done
                                    echo "‚úÖ Deleted $RANGE_COUNT timelines (#$START to #$END)"
                                else
                                    echo "Cancelled."
                                fi
                                exit 0
                            else
                                echo "Invalid range. Please use format like 0-11 within 0-$((TIMELINE_COUNT-1))"
                            fi
                        elif [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 0 ] && [ "$choice" -lt "$TIMELINE_COUNT" ]; then
                            # Get all timeline branches and convert display index to array index
                            TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-'))
                            ARRAY_INDEX=$((${#TIMELINES[@]} - 1 - choice))
                            TIMELINE_BRANCH="${TIMELINES[$ARRAY_INDEX]}"
                            
                            echo ""
                            echo "‚ö†Ô∏è  Delete timeline: $TIMELINE_BRANCH?"
                            read -p "Are you sure? (y/N): " -n 1 -r
                            echo
                            if [[ $REPLY =~ ^[Yy]$ ]]; then
                                git branch -D "$TIMELINE_BRANCH" >/dev/null 2>&1
                                echo "‚úÖ Deleted timeline #$choice"
                            else
                                echo "Cancelled."
                            fi
                            exit 0
                        else
                            echo "Invalid selection. Please choose a, 0-$((TIMELINE_COUNT-1)), x-y range, or press Enter to cancel."
                        fi
                        ;;
                esac
            done
            ;;
        "cleanup")
            echo "üßπ Cleanup Orphaned Timeline Branches"
            echo "======================================"
            echo ""
            
            # Get all existing branches (local and remote), excluding timeline branches  
            EXISTING_BRANCHES=$(git branch -a | sed 's/^[* ]*//' | grep -v 'timelines/' | sed 's/^remotes\///' | sort -u)
            
            # Find orphaned timeline branches
            ORPHANED_BRANCHES=()
            
            echo "Checking timeline branches..."
            ALL_TIMELINE_BRANCHES=$(git branch --list "timelines/*" | sed 's/^[\* ]*//')
            
            for timeline_branch in $ALL_TIMELINE_BRANCHES; do
                # Extract the base branch name from timelines/branch-name/timestamp
                base_branch=$(echo "$timeline_branch" | sed 's|^timelines/||' | cut -d'/' -f1)
                
                # Skip if base branch still exists
                if echo "$EXISTING_BRANCHES" | grep -qx "$base_branch" || \
                   echo "$EXISTING_BRANCHES" | grep -qx "origin/$base_branch"; then
                    continue
                fi
                
                # Get commit info
                commit_msg=$(git log --oneline -1 "$timeline_branch" 2>/dev/null | cut -d' ' -f2- || echo "")
                ORPHANED_BRANCHES+=("$timeline_branch:$base_branch:$commit_msg")
            done
            
            if [ ${#ORPHANED_BRANCHES[@]} -eq 0 ]; then
                echo "‚úÖ No orphaned timeline branches found."
                exit 0
            fi
            
            echo "Found ${#ORPHANED_BRANCHES[@]} orphaned timeline branches:"
            echo ""
            
            # Display individual timeline branches with numbers
            for i in "${!ORPHANED_BRANCHES[@]}"; do
                IFS=':' read -r full_branch base_branch commit_msg <<< "${ORPHANED_BRANCHES[$i]}"
                printf "  %2d: %s\n" "$i" "$full_branch"
                printf "      %s\n" "$commit_msg"
            done
            
            echo ""
            echo "Options:"
            echo "  a) Remove all orphaned timeline branches"
            if [ ${#ORPHANED_BRANCHES[@]} -gt 0 ]; then
                echo "  0-$((${#ORPHANED_BRANCHES[@]} - 1))) Remove specific timeline by number"
            fi
            echo ""
            
            while true; do
                read -p "Select option (or press Enter to cancel): " choice
                
                # Handle cancel - empty input or quit commands
                if [ -z "$choice" ] || [ "$choice" = "q" ] || [ "$choice" = "Q" ] || [ "$choice" = "quit" ] || [ "$choice" = "exit" ] || [ "$choice" = "cancel" ]; then
                    echo "Cancelled."
                    exit 0
                fi
                
                case "$choice" in
                    "a"|"A")
                        echo ""
                        echo "‚ö†Ô∏è  This will permanently delete ALL orphaned timeline branches."
                        read -p "Are you sure? (y/N): " -n 1 -r
                        echo ""
                        if [[ $REPLY =~ ^[Yy]$ ]]; then
                            for orphaned in "${ORPHANED_BRANCHES[@]}"; do
                                IFS=':' read -r full_branch _ _ <<< "$orphaned"
                                echo "üóëÔ∏è  Removing branch: $full_branch"
                                git branch -D "$full_branch" 2>/dev/null || true
                            done
                            echo "‚úÖ Removed ${#ORPHANED_BRANCHES[@]} orphaned timeline branches"
                        else
                            echo "Cancelled."
                        fi
                        exit 0
                        ;;
                    *)
                        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 0 ] && [ "$choice" -lt ${#ORPHANED_BRANCHES[@]} ]; then
                            # Get the selected timeline branch
                            IFS=':' read -r selected_branch _ _ <<< "${ORPHANED_BRANCHES[$choice]}"
                            
                            echo ""
                            echo "‚ö†Ô∏è  This will permanently delete timeline: $selected_branch"
                            read -p "Are you sure? (y/N): " -n 1 -r
                            echo ""
                            if [[ $REPLY =~ ^[Yy]$ ]]; then
                                echo "üóëÔ∏è  Removing branch: $selected_branch"
                                git branch -D "$selected_branch" 2>/dev/null || true
                                echo "‚úÖ Removed timeline branch: $selected_branch"
                            else
                                echo "Cancelled."
                            fi
                            exit 0
                        else
                            echo "Invalid selection. Please choose a, 0-$((${#ORPHANED_BRANCHES[@]} - 1)), or press Enter to cancel."
                        fi
                        ;;
                esac
            done
            ;;
        "view")
            # Quick view - show all timelines with file changes
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null)
            
            # Get all timeline branches and filter out those identical to HEAD
            ALL_TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/*" 2>/dev/null))
            TIMELINES=()
            
            # Filter out timelines that are identical to HEAD
            for timeline in "${ALL_TIMELINES[@]}"; do
                if [ -n "$(git diff --name-only HEAD "$timeline" 2>/dev/null)" ]; then
                    TIMELINES+=("$timeline")
                fi
            done
            
            if [ ${#TIMELINES[@]} -eq 0 ]; then
                echo "No timelines with changes found for branch '$CURRENT_BRANCH'"
                exit 0
            fi
            
            echo "Found ${#TIMELINES[@]} timelines for branch '$CURRENT_BRANCH'"
            echo ""
            
            # Display each timeline with changes
            for ((i=${#TIMELINES[@]}-1; i>=0; i--)); do
                # Calculate display index (0 = oldest, higher = newer)
                DISPLAY_INDEX=$((${#TIMELINES[@]} - 1 - i))
                BRANCH="${TIMELINES[$i]}"
                
                # Get timeline info
                SUBJECT=$(git log -1 --pretty=format:"%s" "$BRANCH" 2>/dev/null)
                timeline_info=$(echo "$SUBJECT" | sed 's/ - [0-9]* files$//')
                
                echo "üìç $timeline_info"
                
                # Use shared function to display changes
                display_timeline_changes "$BRANCH" "HEAD"
                echo ""
            done
            ;;
        "browse")
            # Browse files in a specific timeline
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null)
            
            # Get all timeline branches and filter out those identical to HEAD
            ALL_TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/*" 2>/dev/null))
            TIMELINES=()
            
            # Filter out timelines that are identical to HEAD
            for timeline in "${ALL_TIMELINES[@]}"; do
                if [ -n "$(git diff --name-only HEAD "$timeline" 2>/dev/null)" ]; then
                    TIMELINES+=("$timeline")
                fi
            done
            
            # Outer loop for timeline selection
            while true; do
                # Use the same display function as travel
                display_timeline "$CURRENT_BRANCH" "$CURRENT_HEAD"
                echo ""
                read -p "Select timeline number to browse (or press Enter to exit): " TIMELINE_NUM
                
                if [ -z "$TIMELINE_NUM" ]; then
                    echo "Exiting browse mode."
                    exit 0
                fi
                
                if [ "$TIMELINE_NUM" -lt 0 ] || [ "$TIMELINE_NUM" -ge "${#TIMELINES[@]}" ] 2>/dev/null; then
                    echo "Invalid selection. Please choose 0-$((${#TIMELINES[@]} - 1))"
                    echo ""
                    continue
                fi
                
                # Convert display index to array index
                # Display: 0=oldest, highest=newest
                # Array: 0=newest, highest=oldest
                ARRAY_INDEX=$((${#TIMELINES[@]} - 1 - TIMELINE_NUM))
                
                # Show files in selected timeline
                BRANCH="${TIMELINES[$ARRAY_INDEX]}"
                
                # Inner loop to allow viewing multiple files
                while true; do
                echo ""
                echo "Files different from current workspace in timeline $TIMELINE_NUM:"
                # Only show files that are different from HEAD and have actual diff content
                POTENTIAL_FILES=$(git diff --name-only HEAD "$BRANCH" 2>/dev/null)
                FILE_ARRAY=()
                
                if [ -n "$POTENTIAL_FILES" ]; then
                    # Double-check each file has actual diff content
                    while IFS= read -r file; do
                        if [ -n "$(git diff HEAD "$BRANCH" -- "$file" 2>/dev/null)" ]; then
                            FILE_ARRAY+=("$file")
                        fi
                    done <<< "$POTENTIAL_FILES"
                fi
                
                if [ ${#FILE_ARRAY[@]} -gt 0 ]; then
                    
                    # Display files with numbers
                    for idx in "${!FILE_ARRAY[@]}"; do
                        printf "  %2d) %s\n" "$((idx + 1))" "${FILE_ARRAY[$idx]}"
                    done
                    
                    echo ""
                    read -p "Select file number to view diff (or press Enter to go back): " FILE_NUM
                    
                    if [ -z "$FILE_NUM" ]; then
                        # Enter pressed - go back to timeline selection
                        break
                    elif [ "$FILE_NUM" -ge 1 ] && [ "$FILE_NUM" -le "${#FILE_ARRAY[@]}" ] 2>/dev/null; then
                        SELECTED_FILE="${FILE_ARRAY[$((FILE_NUM - 1))]}"
                        echo ""
                        echo "Diff for $SELECTED_FILE (compared to current workspace):"
                        echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
                        # Always compare against current HEAD to show what would change
                        # Use --color=always to force colors even in pipes
                        DIFF_OUTPUT=$(git diff --color=always HEAD "$BRANCH" -- "$SELECTED_FILE" 2>/dev/null)
                        
                        if [ -n "$DIFF_OUTPUT" ]; then
                            # Show the diff with colors and context
                            echo "$DIFF_OUTPUT"
                            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
                            echo "Legend: $(tput setaf 1)- removed from current$(tput sgr0) | $(tput setaf 2)+ added in timeline$(tput sgr0)"
                        else
                            echo "  (no changes - file is identical to current workspace)"
                        fi
                        
                        # Wait for user to press Enter before showing file list again
                        echo ""
                        read -p "Press Enter to continue..."
                    else
                        echo "Invalid selection. Please choose 1-${#FILE_ARRAY[@]} or press Enter to go back."
                    fi
                else
                    echo "  (no files with differences)"
                    break
                fi
            done  # End inner loop (file selection)
            done  # End outer loop (timeline selection)
            ;;
        "search")
            # Search functionality
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null)
            
            # Check for pattern argument
            if [ -n "$2" ]; then
                # Pattern provided as argument
                PATTERN="$2"
            else
                # Direct search prompt
                read -p "üîç Enter search query: " PATTERN
                if [ -z "$PATTERN" ]; then
                    echo "No search query provided."
                    exit 1
                fi
            fi
            
            # Default to searching both content and filenames
            SEARCH_CONTENT=true
            SEARCH_FILENAMES=true
            
            
            # Get all timeline branches sorted by date (newest first) and filter out those identical to HEAD
            ALL_TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/*" 2>/dev/null))
            TIMELINES=()
            
            # Filter out timelines that are identical to HEAD
            for timeline in "${ALL_TIMELINES[@]}"; do
                if [ -n "$(git diff --name-only HEAD "$timeline" 2>/dev/null)" ]; then
                    TIMELINES+=("$timeline")
                fi
            done
            
            # If still no timelines found, try a different approach
            if [ ${#TIMELINES[@]} -eq 0 ] && [ ${#ALL_TIMELINES[@]} -eq 0 ]; then
                ALL_TIMELINES=($(git branch --list "timelines/$CURRENT_BRANCH/*" 2>/dev/null | sed 's/^[* ]*//' | sort -r))
                for timeline in "${ALL_TIMELINES[@]}"; do
                    if [ -n "$(git diff --name-only HEAD "$timeline" 2>/dev/null)" ]; then
                        TIMELINES+=("$timeline")
                    fi
                done
            fi
            
            if [ ${#TIMELINES[@]} -eq 0 ]; then
                echo "No timeline timelines with changes found for branch '$CURRENT_BRANCH'"
                echo "Debug: Looking for timelines/$CURRENT_BRANCH/*"
                echo "Available timelines:"
                git branch --list "timelines/*" | head -5
                exit 0
            fi
            
            # Perform search
            echo "Searching for '$PATTERN' in ${#TIMELINES[@]} timelines..."
            echo ""
            
            FOUND_ANY=false
            SEARCH_TIMELINES=("${TIMELINES[@]}")
                
                # Search in selected timeline(s)
                for BRANCH in "${SEARCH_TIMELINES[@]}"; do
                # Get timeline index for display
                for idx in "${!TIMELINES[@]}"; do
                    if [ "${TIMELINES[$idx]}" = "$BRANCH" ]; then
                        # Display index is same as array index (0 = oldest)
                        TIMELINE_INDEX=$idx
                        break
                    fi
                done
                
                # Get timeline info
                SUBJECT=$(git log -1 --pretty=format:"%s" "$BRANCH" 2>/dev/null)
                timeline_info=$(echo "$SUBJECT" | sed 's/ - [0-9]* files$//')
                
                # Search based on user selection
                CONTENT_MATCHES=""
                FILENAME_MATCHES=""
                CHANGED_MATCHES=""
                
                if [ "$SEARCH_CONTENT" = true ]; then
                    # Only search in files that are different from HEAD
                    CHANGED_FILES=$(git diff --name-only HEAD "$BRANCH" 2>/dev/null)
                    if [ -n "$CHANGED_FILES" ]; then
                        CONTENT_MATCHES=""
                        while IFS= read -r file; do
                            # Check if this file contains the pattern
                            if git grep -q "$PATTERN" "$BRANCH" -- "$file" 2>/dev/null; then
                                CONTENT_MATCHES="${CONTENT_MATCHES}${file}"$'\n'
                            fi
                        done <<< "$CHANGED_FILES"
                    fi
                fi
                
                if [ "$SEARCH_FILENAMES" = true ]; then
                    # Only search in files that are different from HEAD
                    FILENAME_MATCHES=$(git diff --name-only HEAD "$BRANCH" 2>/dev/null | grep -i "$PATTERN" 2>/dev/null || echo "")
                fi
                
                if [ "$SEARCH_CHANGED_ONLY" = true ]; then
                    # Search only in changed lines (additions and deletions)
                    DIFF_OUTPUT=$(git diff HEAD "$BRANCH" 2>/dev/null | grep -E "^[+-].*$PATTERN" | grep -v '^+++\|^---' || true)
                    if [ -n "$DIFF_OUTPUT" ]; then
                        CHANGED_MATCHES="$DIFF_OUTPUT"
                    fi
                fi
                
                # Display results if any matches found
                if [ -n "$CONTENT_MATCHES" ] || [ -n "$FILENAME_MATCHES" ] || [ -n "$CHANGED_MATCHES" ]; then
                    if [ "$FOUND_ANY" = false ]; then
                        FOUND_ANY=true
                    fi
                    
                    echo "üìç $timeline_info"
                    
                    if [ -n "$CHANGED_MATCHES" ]; then
                        echo "   Changed lines matching '$PATTERN':"
                        echo "$CHANGED_MATCHES" | head -20 | while IFS= read -r line; do
                            echo "      $line"
                        done
                    fi
                    
                    if [ -n "$CONTENT_MATCHES" ]; then
                        echo "   Content matches:"
                        while IFS= read -r file; do
                            if [ -n "$file" ]; then
                                echo "      üìÑ $file:"
                                # Show all matching lines in this file
                                git grep -n "$PATTERN" "$BRANCH" -- "$file" 2>/dev/null | while IFS= read -r match; do
                                    # Extract line number and match content
                                    LINE_INFO=$(echo "$match" | sed "s|^$BRANCH:$file:||")
                                    # Format as "line 123: content"
                                    LINE_NUM=$(echo "$LINE_INFO" | cut -d: -f1)
                                    LINE_CONTENT=$(echo "$LINE_INFO" | cut -d: -f2-)
                                    echo "         line $LINE_NUM: $LINE_CONTENT" | cut -c1-80
                                done | head -5  # Limit to 5 matches per file
                            fi
                        done <<< "$CONTENT_MATCHES"
                    fi
                    
                    if [ -n "$FILENAME_MATCHES" ]; then
                        echo "   Filename matches:"
                        while IFS= read -r file; do
                            if [ -n "$file" ]; then
                                echo "      $file"
                            fi
                        done <<< "$FILENAME_MATCHES"
                    fi
                    
                    echo ""
                fi
            done
            
            if [ "$FOUND_ANY" = false ]; then
                echo "No matches found for '$PATTERN' in any timeline"
            else
                echo "üí° Use 'timeline travel' to go to a specific timeline"
            fi
            
            exit 0
            ;;
        "travel")
            # Get current branch name
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null || exit 0)
            
            # Outer loop for timeline selection
            while true; do
                # Display timeline using shared function
                if ! display_timeline "$CURRENT_BRANCH" "$CURRENT_HEAD"; then
                    exit 0
                fi
                
                echo ""
                
                # Always prompt for selection (ignore any arguments)
                read -p "Select timeline number to travel to (0-$((${#TIMELINES[@]} - 1)), or press Enter to exit): " SELECTION
                
                # Handle quit - accept empty input
                if [ -z "$SELECTION" ]; then
                    echo "Exiting travel mode."
                    exit 0
                fi
                
                # Check if argument is a number (timeline) or commit ID
                if [[ "$SELECTION" =~ ^[0-9]+$ ]]; then
                    # Validate number is in range
                    if [ "$SELECTION" -lt 0 ] || [ "$SELECTION" -ge ${#TIMELINES[@]} ]; then
                        echo "Invalid selection. Please choose 0-$((${#TIMELINES[@]} - 1))"
                        echo ""
                        continue
                    fi
                    
                    # Convert display index to array index
                    # Display: 0=oldest, highest=newest
                    # Array: 0=newest, highest=oldest  
                    ARRAY_INDEX=$((${#TIMELINES[@]} - 1 - SELECTION))
                    TIMELINE_BRANCH="${TIMELINES[$ARRAY_INDEX]}"
                
                # Show preview of what will change
                echo ""
                echo "üìã Preview of changes when traveling to this timeline:"
                echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
                
                # Use shared function to display changes
                display_timeline_changes "$TIMELINE_BRANCH" "HEAD"
                
                # Show summary stats
                STATS=$(git diff --shortstat HEAD "$TIMELINE_BRANCH" 2>/dev/null)
                if [ -n "$STATS" ]; then
                    echo ""
                    echo "   Summary: $STATS"
                fi
                echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
                
                # Get the timeline commit SHA
                TIMELINE_SHA=$(git rev-parse "$TIMELINE_BRANCH")
                
                # Inner loop for confirmation
                while true; do
                    # Option 1: Full restore - completely replace working directory with timeline
                    # This is destructive but exact
                    echo ""
                    read -p "‚ö†Ô∏è  Travel to this timeline? (y to confirm, Enter to go back): " -n 1 -r
                    echo
                    
                    if [ -z "$REPLY" ]; then
                        # Enter pressed - go back to timeline selection
                        echo ""
                        break
                    elif [[ $REPLY =~ ^[Yy]$ ]]; then
                    # Check if there are any changes to backup
                    if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
                        # Save current work as a backup timeline first
                        echo "üì∏ Creating backup timeline before time travel..."
                        BACKUP_TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
                        BACKUP_MSG="timeline-backup: before-travel@$BACKUP_TIMESTAMP"
                        
                        # Create backup using same plumbing approach
                        export GIT_INDEX_FILE=$(mktemp)
                        git read-tree HEAD >/dev/null 2>&1
                        git add --all >/dev/null 2>&1
                        BACKUP_TREE=$(git write-tree)
                        BACKUP_COMMIT=$(echo "$BACKUP_MSG" | git commit-tree $BACKUP_TREE -p HEAD)
                        git update-ref "refs/heads/timelines/$CURRENT_BRANCH/backup-$BACKUP_TIMESTAMP" $BACKUP_COMMIT >/dev/null 2>&1
                        rm -f $GIT_INDEX_FILE
                        unset GIT_INDEX_FILE
                        
                        echo "‚úÖ Backup created: timelines/$CURRENT_BRANCH/backup-$BACKUP_TIMESTAMP"
                    else
                        echo "‚ÑπÔ∏è  No changes to backup (working directory is clean)"
                    fi
                    
                    # Now restore from timeline to working directory only (preserve staging area)
                    # Use git restore with --worktree flag (Git 2.23+) or fallback to checkout
                    if git restore --help >/dev/null 2>&1; then
                        # Modern git with restore command
                        git restore --source="$TIMELINE_BRANCH" --worktree . >/dev/null 2>&1
                    else
                        # Fallback: checkout to temp location and copy
                        TEMP_DIR=$(mktemp -d)
                        git --work-tree="$TEMP_DIR" checkout "$TIMELINE_BRANCH" -- . >/dev/null 2>&1
                        cp -r "$TEMP_DIR"/* . 2>/dev/null || true
                        rm -rf "$TEMP_DIR"
                    fi
                    
                    echo "‚úÖ Traveled to timeline #$SELECTION (unstaged changes)"
                    echo "üí° Your staged changes are preserved"
                    echo "üí° Use 'git status' to see all changes"
                    echo "üí° Use 'timeline travel' to see backup timeline"
                    
                    # Exit after successful travel
                    exit 0
                    else
                        # User didn't confirm
                        echo "Travel cancelled."
                        break
                    fi
                done  # End inner confirmation loop
                
            else
                # Handle commit travel by commit ID
                if ! git rev-parse --verify "$SELECTION" >/dev/null 2>&1; then
                    echo "Error: '$SELECTION' is not a valid timeline number or commit ID"
                    exit 1
                fi
                
                echo "üîÑ Traveling to commit: $SELECTION"
                
                # Confirm before resetting to commit
                read -p "This will reset your working directory to commit $SELECTION. Continue? (y/N): " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    echo "Cancelled."
                    exit 0
                fi
                
                git reset --hard "$SELECTION"
                echo "‚úÖ Reset to commit $SELECTION"
                echo "üí° Use 'git status' to see the current state"
                exit 0
            fi
            done  # End outer while loop for timeline selection
            ;;
        *)
            echo "Usage:"
            echo "  timeline save             - Create a timeline manually"
            echo "  timeline travel           - Show timelines and travel interactively"
            echo "  timeline view             - Quick view all timelines with changes"
            echo "  timeline browse           - Browse files in a specific timeline"
            echo "  timeline search [pattern] - Search for text across timelines"
            echo "  timeline delete           - Delete timelines interactively"
            echo "  timeline cleanup          - Clean up timelines for deleted branches"
            echo "  timeline install          - Install hook to Claude Code"
            echo "  timeline uninstall        - Remove hook from Claude Code"
            exit 1
            ;;
    esac
else
    # No arguments - show help
    echo "Usage:"
    echo "  timeline save             - Create a timeline manually"
    echo "  timeline travel           - Show timelines and travel interactively"
    echo "  timeline view             - Quick view all timelines with changes"
    echo "  timeline browse           - Browse files in a specific timeline"
    echo "  timeline search [pattern] - Search for text across timelines"
    echo "  timeline delete           - Delete timelines interactively"
    echo "  timeline cleanup          - Clean up timelines for deleted branches"
    echo "  timeline install          - Install hook to Claude Code"
    echo "  timeline uninstall        - Remove hook from Claude Code"
    exit 0
fi

# Check if we're in a git repo first
if ! git rev-parse --git-dir >/dev/null 2>&1; then
    # Not a git repo, exit silently
    exit 0
fi

# Get current branch and last timeline
CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
LAST_TIMELINE=$(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-' | head -1)

# Always check against last timeline if it exists
if [ -n "$LAST_TIMELINE" ]; then
    # Create a temporary index for the last timeline to compare untracked files
    export GIT_INDEX_FILE=$(mktemp)
    git read-tree "$LAST_TIMELINE" >/dev/null 2>&1
    LAST_TREE=$(git write-tree 2>/dev/null)
    rm -f $GIT_INDEX_FILE
    unset GIT_INDEX_FILE
    
    # Create a temporary index for current state
    export GIT_INDEX_FILE=$(mktemp)
    git read-tree HEAD >/dev/null 2>&1
    git add --all >/dev/null 2>&1
    CURRENT_TREE=$(git write-tree 2>/dev/null)
    rm -f $GIT_INDEX_FILE
    unset GIT_INDEX_FILE
    
    # If the trees are identical, no changes since last timeline
    if [ "$LAST_TREE" = "$CURRENT_TREE" ]; then
        # No changes since last timeline, exit silently
        exit 0
    fi
else
    # No previous timeline exists, check if there are any changes from HEAD
    if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null || [ -n "$(git ls-files --others --exclude-standard 2>/dev/null)" ]; then
        # Changes exist, continue to create timeline
        :
    else
        # No changes from HEAD and no previous timeline, exit silently
        exit 0
    fi
fi

# Get current branch name and working directory info
CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null) || exit 0
SHORT_HEAD=$(git rev-parse --short HEAD)

# Get the commit message of current HEAD
COMMIT_MSG=$(git log -1 --pretty=format:"%s" HEAD)

# Find the next timeline number for this base commit
TIMELINE_NUM=0
EXISTING_TIMELINES=$(git branch --list "timelines/$CURRENT_BRANCH/+*" 2>/dev/null | sed 's/^[\* ]*//')
if [ -n "$EXISTING_TIMELINES" ]; then
    # Look for timelines with same base commit
    for branch in $EXISTING_TIMELINES; do
        # Check if this timeline is based on current HEAD
        if git log -1 --pretty=format:"%s" "$branch" 2>/dev/null | grep -q "@$SHORT_HEAD"; then
            # Extract the number from branch name like "+0", "+1", etc
            num=$(echo "$branch" | sed -n "s|timelines/$CURRENT_BRANCH/+\([0-9]*\).*|\1|p")
            if [ -n "$num" ] && [ "$num" -ge "$TIMELINE_NUM" ]; then
                TIMELINE_NUM=$((num + 1))
            fi
        fi
    done
fi

# Create timeline branch name with +N format and commit message
# Clean commit message to be branch-safe (remove special chars)
SAFE_MSG=$(echo "$COMMIT_MSG" | sed 's/[^a-zA-Z0-9._-]/_/g' | cut -c1-50)
TIMELINE_BRANCH="timelines/$CURRENT_BRANCH/+${TIMELINE_NUM}_${SAFE_MSG}"

# Create timeline using git plumbing commands (zero working directory impact)
# This creates a real git commit without touching the working directory or index

# Step 1: Create a temporary index to work with (doesn't affect the real index)
export GIT_INDEX_FILE=$(mktemp)
trap "rm -f $GIT_INDEX_FILE" EXIT

# Step 2: Read current HEAD into our temporary index
git read-tree HEAD >/dev/null 2>&1

# Step 3: Update temporary index with current working tree state
# This captures both staged and unstaged changes in their final form
git add --all >/dev/null 2>&1

# Step 4: Write the tree object from our temporary index
TREE_SHA=$(git write-tree)

# Step 5: Count changed files for commit message
FILE_COUNT=$(git diff-index --name-only HEAD | wc -l | tr -d ' ')

# Step 6: Create the commit object (without updating any refs yet)
TIMELINE_MSG="+$TIMELINE_NUM $COMMIT_MSG @$SHORT_HEAD - $FILE_COUNT files"
TIMELINE_COMMIT=$(echo "$TIMELINE_MSG" | git commit-tree $TREE_SHA -p $CURRENT_HEAD)

# Step 7: Create a branch reference for this timeline
git update-ref "refs/heads/$TIMELINE_BRANCH" $TIMELINE_COMMIT >/dev/null 2>&1

# Clean up temp index
rm -f $GIT_INDEX_FILE
unset GIT_INDEX_FILE

# Silent completion - no output needed since this runs automatically via hooks