#!/bin/bash

# Timeline - git-based timeline utility for tracking file changes
# Usage: 
#   - Called automatically by Claude Code after tool use (no args)
#   - timeline list             - List all timelines
#   - timeline travel <number>    - Travel to a specific timeline by number
#   - timeline travel <commit-id> - Travel to a specific git commit
#   - timeline install          - Install hook to Claude Code
#   - timeline uninstall        - Remove hook from Claude Code


# TODO: use git config to do this and display the diff in editor /usr/bin/git -C "/Users/steven_chong/Downloads/repos/kepler_app_594-deploy-cloud-sql-postgresq" -c "core.editor=/Applications/Cursor.app/Contents/Resources/app/bin/cursor --wait --reuse-window" -c "sequence.editor=/Applications/Cursor.app/Contents/Resources/app/bin/cursor --wait --reuse-window" rebase --interactive 32d5957ae5984e7323cab60d52af4c8396d3ba20

set -e

# Auto-detect script location
SCRIPT_PATH="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"

# Shared function to display session stats line
display_session_stats() {
    local session_id="$1"
    local prefix="${2:-}"  # Optional prefix text
    
    # Try different possible paths for the session file
    local session_file=""
    for path in "$HOME/.claude/projects/-Users-steven-chong-Downloads-repos-timeline/${session_id}.jsonl" \
                "$HOME/.claude/projects/"*"/${session_id}.jsonl"; do
        if [ -f "$path" ]; then
            session_file="$path"
            break
        fi
    done
    
    if [ -f "$session_file" ]; then
        # Get stats: timestamp, total messages, user prompts
        # Find first line with timestamp (not all lines have it)
        first_timestamp=$(grep -m 1 '"timestamp"' "$session_file" 2>/dev/null | jq -r '.timestamp // empty' 2>/dev/null)
        total_lines=$(wc -l < "$session_file" 2>/dev/null | tr -d ' ')
        user_messages=$(grep -c '"role":"user"' "$session_file" 2>/dev/null || echo "0")
        
        # Format stats line
        if [ -n "$first_timestamp" ]; then
            date_part=$(echo "$first_timestamp" | cut -d'T' -f1)
            time_part=$(echo "$first_timestamp" | cut -d'T' -f2 | cut -d'.' -f1)
            echo "${prefix}${date_part} ${time_part} | ${total_lines} messages, ${user_messages} user prompts"
        else
            echo "${prefix}Session: ${session_id} | ${total_lines} messages"
        fi
        
        # Return the session file path for further use
        echo "$session_file" > /tmp/timeline_session_file_$$
        return 0
    else
        echo "${prefix}Session: ${session_id}"
        return 1
    fi
}

# Shared function to display first user message (2 lines)
display_first_user_message() {
    local session_file="$1"
    local indent="${2:-  }"  # Default indent
    
    if [ -f "$session_file" ]; then
        # Try different JSON structures for user messages
        # Some have .message.content as string, some as array
        first_user_msg=$(grep '"role":"user"' "$session_file" 2>/dev/null | head -1 | jq -r '
            if .message.content | type == "string" then 
                .message.content
            elif .message.content | type == "array" then
                .message.content[0].text // empty
            else
                empty
            end' 2>/dev/null)
        
        if [ -n "$first_user_msg" ]; then
            # Default to 120 characters width
            WIDTH=120
            # Reserve some space for indent and quotes
            WIDTH=$((WIDTH - ${#indent} - 6))
            
            # Get first 2 lines, using available width (max 500)
            line1=$(echo "$first_user_msg" | head -1 | cut -c1-${WIDTH})
            line2=$(echo "$first_user_msg" | head -2 | tail -1 | cut -c1-${WIDTH})
            
            if [ -n "$line1" ]; then
                echo "${indent}üí¨ \"${line1}"
                if [ -n "$line2" ] && [ "$line1" != "$line2" ]; then
                    echo "${indent}    ${line2}\""
                else
                    echo "${indent}    ...\""
                fi
            fi
        fi
    fi
}

# Function to find current Claude Code session JSONL
get_current_claude_session() {
    local PROJECT_DIR="$HOME/.claude/projects"
    if [ -d "$PROJECT_DIR" ]; then
        # Find the project directory that matches our current working directory
        # Claude encodes paths but may have variations in encoding  
        local CWD=$(pwd)
        local PROJECT_PATH=""
        
        # Try different encoding patterns that Claude might use
        for dir in "$PROJECT_DIR"/*; do
            if [ -d "$dir" ] && [[ "$(basename "$dir")" == *"timeline"* ]]; then
                PROJECT_PATH="$dir"
                break
            fi
        done
        
        if [ -d "$PROJECT_PATH" ]; then
            # Find the most recent JSONL file (current or most recent session)
            local LATEST_JSONL=$(find "$PROJECT_PATH" -name "*.jsonl" -type f -exec stat -f "%m %N" {} \; 2>/dev/null | sort -nr | head -1 | cut -d' ' -f2-)
            if [ -f "$LATEST_JSONL" ]; then
                # Extract just the session ID (UUID) from the filename
                basename "$LATEST_JSONL" .jsonl
                return 0
            fi
        fi
    fi
    return 1
}

# Get the full path to the current Claude session JSONL file
get_current_claude_session_file() {
    local PROJECT_DIR="$HOME/.claude/projects"
    if [ -d "$PROJECT_DIR" ]; then
        local CWD=$(pwd)
        local PROJECT_PATH=""
        
        for dir in "$PROJECT_DIR"/*; do
            if [ -d "$dir" ] && [[ "$(basename "$dir")" == *"timeline"* ]]; then
                PROJECT_PATH="$dir"
                break
            fi
        done
        
        if [ -d "$PROJECT_PATH" ]; then
            local LATEST_JSONL=$(find "$PROJECT_PATH" -name "*.jsonl" -type f -exec stat -f "%m %N" {} \; 2>/dev/null | sort -nr | head -1 | cut -d' ' -f2-)
            if [ -f "$LATEST_JSONL" ]; then
                echo "$LATEST_JSONL"
                return 0
            fi
        fi
    fi
    return 1
}

# Shared function to generate summary line format [+X ~Y -Z] visual +adds -dels lines
generate_summary_line() {
    local added_files="$1"
    local modified_files="$2"
    local removed_files="$3"
    local adds="$4"
    local dels="$5"
    
    # Build file breakdown like [+5 ~3 -1]
    local file_breakdown="["
    if [ "$added_files" -gt 0 ]; then
        file_breakdown="${file_breakdown}+${added_files} "
    fi
    if [ "$modified_files" -gt 0 ]; then
        file_breakdown="${file_breakdown}~${modified_files} "
    fi
    if [ "$removed_files" -gt 0 ]; then
        file_breakdown="${file_breakdown}-${removed_files} "
    fi
    file_breakdown="${file_breakdown%% }]"
    
    # Create visual indicator
    local visual=""
    if [ "$adds" -gt 0 ]; then
        if [ "$adds" -lt 10 ]; then
            visual="${visual}$(printf -- '+%.0s' $(seq 1 $adds))"
        elif [ "$adds" -lt 50 ]; then
            visual="${visual}+++"
        elif [ "$adds" -lt 100 ]; then
            visual="${visual}+++++"
        else
            visual="${visual}+++++++"
        fi
    fi
    
    if [ "$dels" -gt 0 ]; then
        if [ "$dels" -lt 10 ]; then
            visual="${visual}$(printf -- '-%.0s' $(seq 1 $dels))"
        elif [ "$dels" -lt 50 ]; then
            visual="${visual}---"
        elif [ "$dels" -lt 100 ]; then
            visual="${visual}-----"
        else
            visual="${visual}-------"
        fi
    fi
    
    # Return the formatted line
    echo "${file_breakdown}  ${visual}  +${adds} -${dels} lines"
}

# Shared function to display file changes for a timeline
display_timeline_changes() {
    local BRANCH="$1"
    local COMPARE_REF="${2:-HEAD}"  # Default to HEAD if not specified
    
    # Show file breakdown with status indicators
    file_status=$(git diff --name-status "$COMPARE_REF" "$BRANCH" 2>/dev/null)
    if [ -n "$file_status" ]; then
        # Get file counts
        added_files=0
        modified_files=0
        removed_files=0
        
        added_files=$(echo "$file_status" | grep '^A' | wc -l | tr -d ' ')
        modified_files=$(echo "$file_status" | grep '^M' | wc -l | tr -d ' ')
        removed_files=$(echo "$file_status" | grep '^D' | wc -l | tr -d ' ')
        
        # Get line stats
        STATS=$(git diff --shortstat "$COMPARE_REF" "$BRANCH" 2>/dev/null | sed 's/files\? changed/files/' || echo "")
        ADDS=$(echo "$STATS" | grep -oE '[0-9]+ insertion' | grep -o '[0-9]*' | head -1)
        DELS=$(echo "$STATS" | grep -oE '[0-9]+ deletion' | grep -o '[0-9]*' | head -1)
        ADDS=${ADDS:-0}
        DELS=${DELS:-0}
        
        # Use shared function to generate summary line
        summary_line=$(generate_summary_line "$added_files" "$modified_files" "$removed_files" "$ADDS" "$DELS")
        printf "   %s\n" "$summary_line"
    else
        printf "   (no changes)\n"
    fi
}

# Shared function to display timeline entries
display_timeline() {
    local CURRENT_BRANCH="$1"
    local CURRENT_HEAD="$2"
    
    echo "‚è∞ Timeline for branch '$CURRENT_BRANCH':"
    echo ""
    
    # Get all timeline entries sorted by date (newest first), excluding backups
    ALL_TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-' | head -20))
    TIMELINES=()
    
    # Filter out timelines that are identical to HEAD
    for timeline in "${ALL_TIMELINES[@]}"; do
        if [ -n "$(git diff --name-only HEAD "$timeline" 2>/dev/null)" ]; then
            TIMELINES+=("$timeline")
        fi
    done
    
    if [ ${#TIMELINES[@]} -eq 0 ]; then
        echo "No timeline entries found for branch '$CURRENT_BRANCH'"
        return 1
    fi
    
    # Process each timeline (oldest first, newest last)
    # Note: TIMELINES array is sorted newest first, so we need to iterate in reverse
    for ((i=${#TIMELINES[@]}-1; i>=0; i--)); do
        # Calculate display index (0 = oldest, higher = newer)
        DISPLAY_INDEX=$((${#TIMELINES[@]} - 1 - i))
        BRANCH="${TIMELINES[$i]}"
        
        # Get timeline commit message
        SUBJECT=$(git log -1 --pretty=format:"%s" "$BRANCH" 2>/dev/null)
        timeline_info=$(echo "$SUBJECT" | sed 's/ - [0-9]* files$//')
        
        # Always compare against current HEAD to show what would change if you travel to this timeline
        STATS=$(git diff --shortstat HEAD "$BRANCH" 2>/dev/null | sed 's/files\? changed/files/' || echo "")
        
        # Format line
        printf "  %2d: %s\n" "$DISPLAY_INDEX" "$timeline_info"
        
        # Show file breakdown with status indicators
        file_status=$(git diff --name-status HEAD "$BRANCH" 2>/dev/null)
        if [ -n "$file_status" ]; then
            # Get file counts
            added_files=0
            modified_files=0
            removed_files=0
            
            added_files=$(echo "$file_status" | grep '^A' | wc -l | tr -d ' ')
            modified_files=$(echo "$file_status" | grep '^M' | wc -l | tr -d ' ')
            removed_files=$(echo "$file_status" | grep '^D' | wc -l | tr -d ' ')
            
            # Get line stats
            STATS=$(git diff --shortstat HEAD "$BRANCH" 2>/dev/null | sed 's/files\? changed/files/' || echo "")
            ADDS=$(echo "$STATS" | grep -oE '[0-9]+ insertion' | grep -o '[0-9]*' | head -1)
            DELS=$(echo "$STATS" | grep -oE '[0-9]+ deletion' | grep -o '[0-9]*' | head -1)
            ADDS=${ADDS:-0}
            DELS=${DELS:-0}
            
            # Use shared function to generate summary line
            summary_line=$(generate_summary_line "$added_files" "$modified_files" "$removed_files" "$ADDS" "$DELS")
            printf "      %s\n" "$summary_line"
        else
            printf "      (no changes)\n"
        fi
    done
    
    return 0
}

# Handle command line arguments
if [ $# -gt 0 ]; then
    case "$1" in
        "save")
            # Explicit timeline creation - continue to timeline logic below
            ;;
        "install")
            # Use environment variable if set, otherwise default to ~/.claude
            CLAUDE_DIR="${CLAUDE_CONFIG_DIR:-$HOME/.claude}"
            SETTINGS_FILE="$CLAUDE_DIR/settings.json"
            
            echo "üöÄ Timeline Hook Installer"
            echo "========================="
            echo ""
            
            if [ ! -f "$SETTINGS_FILE" ]; then
                echo "‚ùå Claude Code settings file not found at: $SETTINGS_FILE"
                echo "Please make sure Claude Code is installed and configured."
                exit 1
            fi
            
            # Check if already installed (check for script path patterns)
            if grep -q "timeline" "$SETTINGS_FILE"; then
                echo "‚úÖ Timeline hook is already installed in Claude Code settings"
                echo "Current hook references in settings.json:"
                grep -n "timeline" "$SETTINGS_FILE" | head -3
                exit 0
            fi
            
            # Create backup
            cp "$SETTINGS_FILE" "$SETTINGS_FILE.backup"
            echo "üìã Backed up settings to: $SETTINGS_FILE.backup"
            
            # Install hook using jq (similar to claude-lsp-cli installer)
            if command -v jq &> /dev/null; then
                # Add to BOTH PreToolUse and PostToolUse hooks
                # PreToolUse catches state before destructive commands (git checkout, etc)
                # PostToolUse catches state after file edits
                
                # First, add to PostToolUse
                jq --arg cmd "$SCRIPT_PATH save" '.hooks.PostToolUse = ((.hooks.PostToolUse // []) | 
                    if length > 0 and .[0].hooks then
                        if (.[0].hooks | map(.command) | any(contains("timeline"))) then
                            .
                        else
                            .[0].hooks += [{"type": "command", "command": $cmd}]
                        end
                    else
                        . + [{"hooks": [{"type": "command", "command": $cmd}]}]
                    end)' "$SETTINGS_FILE.backup" > "$SETTINGS_FILE.tmp"
                
                # Then, add to PreToolUse (for Bash commands that might destroy changes)
                jq --arg cmd "$SCRIPT_PATH save" '.hooks.PreToolUse = ((.hooks.PreToolUse // []) | 
                    if length > 0 then
                        # Look for Bash matcher
                        map(if .matcher == "Bash" then
                            if (.hooks | map(.command) | any(contains("timeline"))) then
                                .
                            else
                                .hooks += [{"type": "command", "command": $cmd}]
                            end
                        else
                            .
                        end)
                    else
                        # Create new PreToolUse with Bash matcher
                        . + [{"matcher": "Bash", "hooks": [{"type": "command", "command": $cmd}]}]
                    end)' "$SETTINGS_FILE.tmp" > "$SETTINGS_FILE"
                
                rm -f "$SETTINGS_FILE.backup" "$SETTINGS_FILE.tmp"
                echo "‚úÖ Installed timeline hooks to settings.json (Pre and Post)"
            else
                echo "‚ö†Ô∏è  jq not found - please manually add hook to settings.json:"
                echo "  Add to PostToolUse hooks array: {\"type\": \"command\", \"command\": \"$SCRIPT_PATH save\"}"
                echo ""
                echo "Install jq for automatic hook management:"
                echo "  brew install jq  # macOS"
                echo "  apt install jq   # Ubuntu/Debian"
                exit 1
            fi
            
            echo ""
            echo "üéâ Timeline hook installation complete!"
            echo "The hook will now automatically create timeline timelines after any Claude Code tool use."
            echo ""
            echo "Available commands:"
            echo "  timeline travel           - Show and travel to timelines"
            echo "  timeline delete           - Delete timelines"
            echo "  timeline cleanup          - Clean up timelines for deleted branches"
            echo "  timeline uninstall        - Remove the hook"
            echo ""
            echo "Timeline timelines will be stored in: timelines/<branch-name>/"
            exit 0
            ;;
        "uninstall")
            # Use environment variable if set, otherwise default to ~/.claude
            CLAUDE_DIR="${CLAUDE_CONFIG_DIR:-$HOME/.claude}"
            SETTINGS_FILE="$CLAUDE_DIR/settings.json"
            
            echo "üóëÔ∏è  Timeline Hook Uninstaller"
            echo "============================="
            echo ""
            
            if [ ! -f "$SETTINGS_FILE" ]; then
                echo "‚ùå Claude Code settings file not found at: $SETTINGS_FILE"
                exit 1
            fi
            
            # Check if hook is installed (check for any timeline references)
            if ! grep -q "timeline" "$SETTINGS_FILE"; then
                echo "‚úÖ Timeline hook is not currently installed"
                exit 0
            fi
            
            echo "Current hook references found:"
            grep -n "timeline" "$SETTINGS_FILE" | head -3
            
            # Create backup
            cp "$SETTINGS_FILE" "$SETTINGS_FILE.backup"
            echo "üìã Backed up settings to: $SETTINGS_FILE.backup"
            
            # Remove hook using jq (similar to claude-lsp-cli installer logic)
            if command -v jq &> /dev/null; then
                # Remove timeline hooks from both PostToolUse and PreToolUse
                jq '.hooks.PostToolUse = ((.hooks.PostToolUse // []) | 
                    map(.hooks = (.hooks | map(select(.command | test("timeline") | not)))))' "$SETTINGS_FILE.backup" > "$SETTINGS_FILE.tmp"
                
                # Also remove from PreToolUse
                jq '.hooks.PreToolUse = ((.hooks.PreToolUse // []) | 
                    map(if .hooks then 
                        .hooks = (.hooks | map(select(.command | test("timeline") | not)))
                    else 
                        . 
                    end))' "$SETTINGS_FILE.tmp" > "$SETTINGS_FILE"
                
                rm -f "$SETTINGS_FILE.backup" "$SETTINGS_FILE.tmp"
                echo "‚úÖ Timeline hooks removed from settings.json (Pre and Post)"
            else
                echo "‚ö†Ô∏è  jq not found - please manually remove hook from settings.json"
                echo "Look for: {\"type\": \"command\", \"command\": \"$SCRIPT_PATH save\"}"
                exit 1
            fi
            
            echo ""
            echo "üóëÔ∏è  Timeline hook uninstallation complete!"
            echo "The hook will no longer run automatically with Claude Code."
            echo "Your existing timeline timelines are preserved in the timelines/ directories."
            echo ""
            echo "To reinstall: timeline install"
            exit 0
            ;;
        "delete")
            # Interactive delete with options
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null || exit 0)
            
            # Display timeline using shared function
            echo "üóëÔ∏è  Delete Timelines"
            echo "===================="
            if ! display_timeline "$CURRENT_BRANCH" "$CURRENT_HEAD"; then
                exit 0
            fi
            
            # Get timeline count for options
            TIMELINE_COUNT=$(git for-each-ref --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-' | wc -l | tr -d ' ')
            
            echo ""
            echo "Options:"
            echo "  a) Delete all timelines"
            echo "  0-$((TIMELINE_COUNT-1))) Delete specific timeline by number"
            echo "  x-y) Delete range of timelines (e.g., 0-11)"
            echo ""
            
            while true; do
                read -p "Select option (or press Enter to cancel): " choice
                
                # Handle cancel - empty input or quit commands
                if [ -z "$choice" ] || [ "$choice" = "q" ] || [ "$choice" = "Q" ] || [ "$choice" = "quit" ] || [ "$choice" = "exit" ] || [ "$choice" = "cancel" ]; then
                    echo "Cancelled."
                    exit 0
                fi
                
                case "$choice" in
                    "a"|"A")
                        echo ""
                        echo "‚ö†Ô∏è  This will permanently delete ALL $TIMELINE_COUNT timelines."
                        read -p "Are you sure? (y/N): " -n 1 -r
                        echo
                        if [[ $REPLY =~ ^[Yy]$ ]]; then
                            git for-each-ref --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" | grep -v '/backup-' | \
                                xargs -I {} git branch -D {} >/dev/null 2>&1
                            echo "‚úÖ Deleted $TIMELINE_COUNT timelines"
                        else
                            echo "Cancelled."
                        fi
                        exit 0
                        ;;
                    *)
                        # Check for range (e.g., 0-11)
                        if [[ "$choice" =~ ^([0-9]+)-([0-9]+)$ ]]; then
                            START="${BASH_REMATCH[1]}"
                            END="${BASH_REMATCH[2]}"
                            
                            # Validate range
                            if [ "$START" -ge 0 ] && [ "$END" -lt "$TIMELINE_COUNT" ] && [ "$START" -le "$END" ]; then
                                RANGE_COUNT=$((END - START + 1))
                                echo ""
                                echo "‚ö†Ô∏è  This will delete $RANGE_COUNT timelines (from #$START to #$END)"
                                read -p "Are you sure? (y/N): " -n 1 -r
                                echo
                                if [[ $REPLY =~ ^[Yy]$ ]]; then
                                    # Get all timeline branches in order
                                    TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-'))
                                    
                                    # Delete the range (convert display indices to array indices)
                                    for i in $(seq $START $END); do
                                        ARRAY_INDEX=$((${#TIMELINES[@]} - 1 - i))
                                        if [ $ARRAY_INDEX -ge 0 ] && [ $ARRAY_INDEX -lt ${#TIMELINES[@]} ]; then
                                            git branch -D "${TIMELINES[$ARRAY_INDEX]}" >/dev/null 2>&1
                                        fi
                                    done
                                    echo "‚úÖ Deleted $RANGE_COUNT timelines (#$START to #$END)"
                                else
                                    echo "Cancelled."
                                fi
                                exit 0
                            else
                                echo "Invalid range. Please use format like 0-11 within 0-$((TIMELINE_COUNT-1))"
                            fi
                        elif [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 0 ] && [ "$choice" -lt "$TIMELINE_COUNT" ]; then
                            # Get all timeline branches and convert display index to array index
                            TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-'))
                            ARRAY_INDEX=$((${#TIMELINES[@]} - 1 - choice))
                            TIMELINE_BRANCH="${TIMELINES[$ARRAY_INDEX]}"
                            
                            echo ""
                            echo "‚ö†Ô∏è  Delete timeline: $TIMELINE_BRANCH?"
                            read -p "Are you sure? (y/N): " -n 1 -r
                            echo
                            if [[ $REPLY =~ ^[Yy]$ ]]; then
                                git branch -D "$TIMELINE_BRANCH" >/dev/null 2>&1
                                echo "‚úÖ Deleted timeline #$choice"
                            else
                                echo "Cancelled."
                            fi
                            exit 0
                        else
                            echo "Invalid selection. Please choose a, 0-$((TIMELINE_COUNT-1)), x-y range, or press Enter to cancel."
                        fi
                        ;;
                esac
            done
            ;;
        "cleanup")
            echo "üßπ Cleanup Orphaned Timeline Branches"
            echo "======================================"
            echo ""
            
            # Get all existing branches (local and remote), excluding timeline branches  
            EXISTING_BRANCHES=$(git branch -a | sed 's/^[* ]*//' | grep -v 'timelines/' | sed 's/^remotes\///' | sort -u)
            
            # Find orphaned timeline branches
            ORPHANED_BRANCHES=()
            
            echo "Checking timeline branches..."
            ALL_TIMELINE_BRANCHES=$(git branch --list "timelines/*" | sed 's/^[\* ]*//')
            
            for timeline_branch in $ALL_TIMELINE_BRANCHES; do
                # Extract the base branch name from timelines/branch-name/timestamp
                base_branch=$(echo "$timeline_branch" | sed 's|^timelines/||' | cut -d'/' -f1)
                
                # Skip if base branch still exists
                if echo "$EXISTING_BRANCHES" | grep -qx "$base_branch" || \
                   echo "$EXISTING_BRANCHES" | grep -qx "origin/$base_branch"; then
                    continue
                fi
                
                # Get commit info
                commit_msg=$(git log --oneline -1 "$timeline_branch" 2>/dev/null | cut -d' ' -f2- || echo "")
                ORPHANED_BRANCHES+=("$timeline_branch:$base_branch:$commit_msg")
            done
            
            if [ ${#ORPHANED_BRANCHES[@]} -eq 0 ]; then
                echo "‚úÖ No orphaned timeline branches found."
                exit 0
            fi
            
            echo "Found ${#ORPHANED_BRANCHES[@]} orphaned timeline branches:"
            echo ""
            
            # Display individual timeline branches with numbers
            for i in "${!ORPHANED_BRANCHES[@]}"; do
                IFS=':' read -r full_branch base_branch commit_msg <<< "${ORPHANED_BRANCHES[$i]}"
                printf "  %2d: %s\n" "$i" "$full_branch"
                printf "      %s\n" "$commit_msg"
            done
            
            echo ""
            echo "Options:"
            echo "  a) Remove all orphaned timeline branches"
            if [ ${#ORPHANED_BRANCHES[@]} -gt 0 ]; then
                echo "  0-$((${#ORPHANED_BRANCHES[@]} - 1))) Remove specific timeline by number"
            fi
            echo ""
            
            while true; do
                read -p "Select option (or press Enter to cancel): " choice
                
                # Handle cancel - empty input or quit commands
                if [ -z "$choice" ] || [ "$choice" = "q" ] || [ "$choice" = "Q" ] || [ "$choice" = "quit" ] || [ "$choice" = "exit" ] || [ "$choice" = "cancel" ]; then
                    echo "Cancelled."
                    exit 0
                fi
                
                case "$choice" in
                    "a"|"A")
                        echo ""
                        echo "‚ö†Ô∏è  This will permanently delete ALL orphaned timeline branches."
                        read -p "Are you sure? (y/N): " -n 1 -r
                        echo ""
                        if [[ $REPLY =~ ^[Yy]$ ]]; then
                            for orphaned in "${ORPHANED_BRANCHES[@]}"; do
                                IFS=':' read -r full_branch _ _ <<< "$orphaned"
                                echo "üóëÔ∏è  Removing branch: $full_branch"
                                git branch -D "$full_branch" 2>/dev/null || true
                            done
                            echo "‚úÖ Removed ${#ORPHANED_BRANCHES[@]} orphaned timeline branches"
                        else
                            echo "Cancelled."
                        fi
                        exit 0
                        ;;
                    *)
                        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 0 ] && [ "$choice" -lt ${#ORPHANED_BRANCHES[@]} ]; then
                            # Get the selected timeline branch
                            IFS=':' read -r selected_branch _ _ <<< "${ORPHANED_BRANCHES[$choice]}"
                            
                            echo ""
                            echo "‚ö†Ô∏è  This will permanently delete timeline: $selected_branch"
                            read -p "Are you sure? (y/N): " -n 1 -r
                            echo ""
                            if [[ $REPLY =~ ^[Yy]$ ]]; then
                                echo "üóëÔ∏è  Removing branch: $selected_branch"
                                git branch -D "$selected_branch" 2>/dev/null || true
                                echo "‚úÖ Removed timeline branch: $selected_branch"
                            else
                                echo "Cancelled."
                            fi
                            exit 0
                        else
                            echo "Invalid selection. Please choose a, 0-$((${#ORPHANED_BRANCHES[@]} - 1)), or press Enter to cancel."
                        fi
                        ;;
                esac
            done
            ;;
        "view")
            # Check for jq dependency (required for conversation parsing)
            if ! command -v jq &> /dev/null; then
                echo "‚ö†Ô∏è  The 'view' command requires jq for parsing conversation data"
                echo ""
                echo "To install jq:"
                echo "  macOS:    brew install jq"
                echo "  Ubuntu:   apt-get install jq"
                echo "  CentOS:   yum install jq"
                echo ""
                echo "Alternatively, use 'timeline travel' to browse timelines without conversation view"
                exit 1
            fi
            
            # Session-based view - select session first, then view timelines
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null)
            
            # First, let user select a session
            echo "üóÇÔ∏è Available Sessions:"
            echo ""
            
            # Get ALL sessions from the project directory and sort by modification time
            SESSION_LIST=()
            SESSION_FILES=()
            PROJECT_DIR="$HOME/.claude/projects/-Users-steven-chong-Downloads-repos-timeline"
            
            # First, collect all session files with their modification times
            if [ -d "$PROJECT_DIR" ]; then
                for session_file in "$PROJECT_DIR"/*.jsonl; do
                    if [ -f "$session_file" ]; then
                        SESSION_FILES+=("$session_file")
                    fi
                done
            fi
            
            # Also check for any other project directories that might match
            for proj_dir in "$HOME/.claude/projects/"*timeline*; do
                if [ -d "$proj_dir" ] && [ "$proj_dir" != "$PROJECT_DIR" ]; then
                    for session_file in "$proj_dir"/*.jsonl; do
                        if [ -f "$session_file" ]; then
                            # Avoid duplicates by checking if file name already exists
                            session_id=$(basename "$session_file" .jsonl)
                            found=0
                            for existing_file in "${SESSION_FILES[@]}"; do
                                if [ "$(basename "$existing_file" .jsonl)" = "$session_id" ]; then
                                    found=1
                                    break
                                fi
                            done
                            if [ $found -eq 0 ]; then
                                SESSION_FILES+=("$session_file")
                            fi
                        fi
                    done
                fi
            done
            
            # Sort files by modification time (newest first) and extract session IDs
            if [ ${#SESSION_FILES[@]} -gt 0 ]; then
                while IFS= read -r session_file; do
                    session_id=$(basename "$session_file" .jsonl)
                    SESSION_LIST+=("$session_id")
                done < <(printf "%s\n" "${SESSION_FILES[@]}" | xargs -I {} stat -f "%m {}" {} 2>/dev/null | sort -rn | cut -d' ' -f2-)
            fi
            
            # If still no sessions found, try current session
            if [ ${#SESSION_LIST[@]} -eq 0 ]; then
                CURRENT_SESSION=$(get_current_claude_session)
                if [ -n "$CURRENT_SESSION" ]; then
                    session_id=$(basename "$CURRENT_SESSION" .jsonl)
                    SESSION_LIST=("$session_id")
                else
                    echo "No sessions found"
                    exit 0
                fi
            fi
            
            # Get all timeline branches for later use
            ALL_TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/*" 2>/dev/null))
            
            echo "Found ${#SESSION_LIST[@]} session(s)"
            echo ""
            
            # Pre-cache all timeline metadata for faster processing
            echo -n "üîÑ Caching timeline metadata..."
            TIMELINE_CACHE=$(mktemp)
            for timeline in "${ALL_TIMELINES[@]}"; do
                commit_hash=$(git rev-parse "$timeline" 2>/dev/null)
                if [ -n "$commit_hash" ]; then
                    notes=$(git notes --ref=timeline show "$commit_hash" 2>/dev/null || echo "")
                    session_id=$(echo "$notes" | grep "^Session-Id:" | cut -d' ' -f2- | head -1)
                    echo "$timeline|$commit_hash|$session_id" >> "$TIMELINE_CACHE"
                fi
            done
            echo " Done! (${#ALL_TIMELINES[@]} timelines)"
            echo ""
            
            # Generate HTML output with dynamic rendering
            HTML_FILE="/tmp/timeline-view-$(date +%Y%m%d-%H%M%S).html"
            
            # Function to show progress
            show_progress() {
                local current=$1
                local total=$2
                local width=50
                local percent=$((current * 100 / total))
                local filled=$((current * width / total))
                
                printf "\r[" 
                printf "%0.s‚ïê" $(seq 1 $filled)
                printf "%0.s‚îÄ" $(seq $((filled + 1)) $width)
                printf "] %3d%% (%d/%d sessions)" $percent $current $total
            }
            
            # Function to escape strings for JavaScript
            escape_js() {
                echo "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/'"'"'/\\'"'"'/g; s/\n/\\n/g; s/\r/\\r/g; s/\t/\\t/g'
            }
            
            # Generate session data as JavaScript objects in parallel
            echo "const timelineData = {" > /tmp/timeline-data.js
            echo "  sessions: [" >> /tmp/timeline-data.js
            
            # Create temp directory for parallel processing
            TEMP_DIR=$(mktemp -d)
            trap "rm -rf $TEMP_DIR" EXIT
            
            # Function to process a single session (for parallel execution)
            process_session() {
                local session_idx=$1
                local session_id=$2
                local output_file=$3
                
                # Redirect all output to the file
                exec > "$output_file"
                
                # Get session info
                local session_file=""
                for path in "$HOME/.claude/projects/-Users-steven-chong-Downloads-repos-timeline/${session_id}.jsonl" \
                            "$HOME/.claude/projects/"*"/${session_id}.jsonl"; do
                    if [ -f "$path" ]; then
                        session_file="$path"
                        break
                    fi
                done
                
                # Get session timestamps
                local session_create_datetime="Unknown"
                local session_modified_datetime="Unknown"
                
                if [ -f "$session_file" ]; then
                    first_timestamp=$(grep -m 1 '"timestamp"' "$session_file" 2>/dev/null | jq -r '.timestamp // empty' 2>/dev/null | head -1)
                    if [ -n "$first_timestamp" ]; then
                        session_create_datetime="$first_timestamp"
                    fi
                    
                    last_timestamp=$(grep '"timestamp"' "$session_file" 2>/dev/null | tail -1 | jq -r '.timestamp // empty' 2>/dev/null)
                    if [ -n "$last_timestamp" ]; then
                        session_modified_datetime="$last_timestamp"
                    fi
                fi
                
                # Start session object
                echo "    {"
                echo "      id: \"$(escape_js "$session_id")\","
                echo "      index: $session_idx,"
                echo "      created: \"$(escape_js "$session_create_datetime")\","
                echo "      modified: \"$(escape_js "$session_modified_datetime")\","
                echo "      timelines: ["
                
                # Get timelines for this session from cache
                local SESSION_TIMELINES=()
                if [ -f "$TIMELINE_CACHE" ]; then
                    # Fast lookup from cache
                    while IFS='|' read -r timeline commit_hash sid; do
                        if [ "$sid" = "$session_id" ]; then
                            SESSION_TIMELINES+=("$timeline")
                        fi
                    done < "$TIMELINE_CACHE"
                else
                    # Fallback if no cache
                    local CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
                    local ALL_TIMELINES_LOCAL=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/*" 2>/dev/null))
                    for timeline in "${ALL_TIMELINES_LOCAL[@]}"; do
                        commit_hash=$(git rev-parse "$timeline" 2>/dev/null)
                        if [ -n "$commit_hash" ]; then
                            notes=$(git notes --ref=timeline show "$commit_hash" 2>/dev/null || true)
                            if [ -n "$notes" ]; then
                                sid=$(echo "$notes" | grep "^Session-Id:" | cut -d' ' -f2- | head -1)
                                if [ "$sid" = "$session_id" ]; then
                                    SESSION_TIMELINES+=("$timeline")
                                fi
                            fi
                        fi
                    done
                fi
                
                # Add timeline data
                for ((i=${#SESSION_TIMELINES[@]}-1; i>=0; i--)); do
                    DISPLAY_INDEX=$((${#SESSION_TIMELINES[@]} - 1 - i))
                    BRANCH="${SESSION_TIMELINES[$i]}"
                    
                    commit_hash=$(git rev-parse "$BRANCH" 2>/dev/null)
                    short_hash=$(git rev-parse --short "$BRANCH" 2>/dev/null)
                    commit_time=$(git log -1 --pretty=format:"%cr" "$BRANCH" 2>/dev/null)
                    commit_date=$(git log -1 --pretty=format:"%ci" "$BRANCH" 2>/dev/null)
                    commit_msg=$(git log -1 --pretty=format:"%s" "$BRANCH" 2>/dev/null)
                    
                    # Get file statistics
                    STATS=$(git diff --shortstat HEAD "$BRANCH" 2>/dev/null | sed 's/files\? changed/files/')
                    files_changed=$(echo "$STATS" | grep -oE '[0-9]+ file' | grep -o '[0-9]*' | head -1)
                    additions=$(echo "$STATS" | grep -oE '[0-9]+ insertion' | grep -o '[0-9]*' | head -1)
                    deletions=$(echo "$STATS" | grep -oE '[0-9]+ deletion' | grep -o '[0-9]*' | head -1)
                    
                    # Get changed files list
                    changed_files_json="["
                    temp_files=$(mktemp)
                    git diff --name-status HEAD "$BRANCH" 2>/dev/null > "$temp_files" || true
                    first_file=true
                    while IFS=$'\t' read -r status file; do
                        if [ -n "$file" ]; then
                            if [ "$first_file" = false ]; then
                                changed_files_json="${changed_files_json},"
                            fi
                            changed_files_json="${changed_files_json}{\"status\":\"$status\",\"path\":\"$(escape_js "$file")\"}"
                            first_file=false
                        fi
                    done < "$temp_files"
                    rm -f "$temp_files"
                    changed_files_json="${changed_files_json}]"
                    
                    echo "        {" >> /tmp/timeline-data.js
                    echo "          branch: \"$(escape_js "$BRANCH")\"," >> /tmp/timeline-data.js
                    echo "          hash: \"$(escape_js "$commit_hash")\"," >> /tmp/timeline-data.js
                    echo "          shortHash: \"$(escape_js "$short_hash")\"," >> /tmp/timeline-data.js
                    echo "          time: \"$(escape_js "$commit_time")\"," >> /tmp/timeline-data.js
                    echo "          date: \"$(escape_js "$commit_date")\"," >> /tmp/timeline-data.js
                    echo "          message: \"$(escape_js "$commit_msg")\"," >> /tmp/timeline-data.js
                    echo "          displayIndex: $DISPLAY_INDEX," >> /tmp/timeline-data.js
                    echo "          stats: {"
                    echo "            filesChanged: ${files_changed:-0},"
                    echo "            additions: ${additions:-0},"
                    echo "            deletions: ${deletions:-0}"
                    echo "          },"
                    echo "          files: $changed_files_json"
                    if [ $i -eq 0 ]; then
                        echo "        }"
                    else
                        echo "        },"
                    fi
                done
                
                echo "      ]"
                echo "    }"
            }
            
            # Export the function and escape_js for subshells
            export -f process_session
            export -f escape_js
            
            # Process sessions in parallel
            echo "Processing ${#SESSION_LIST[@]} sessions..."
            
            # Pass cache to subprocesses
            export TIMELINE_CACHE
            
            # Start all parallel jobs
            JOBS_STARTED=0
            for session_idx in "${!SESSION_LIST[@]}"; do
                session_id="${SESSION_LIST[$session_idx]}"
                output_file="$TEMP_DIR/session_${session_idx}.json"
                
                # Run session processing in background
                process_session "$session_idx" "$session_id" "$output_file" &
                JOBS_STARTED=$((JOBS_STARTED + 1))
                
                # Limit parallel jobs (max 8)
                while [ $(jobs -r | wc -l) -ge 8 ]; do
                    sleep 0.05
                done
                
                printf "\r  Starting job %d/%d..." $JOBS_STARTED ${#SESSION_LIST[@]}
            done
            
            # Wait for all background jobs
            printf "\r  Waiting for jobs to complete..."
            wait
            printf "\r%*s\r" 50 ""
            echo "‚úÖ Processing complete!"
            
            # Combine results in order
            for session_idx in "${!SESSION_LIST[@]}"; do
                output_file="$TEMP_DIR/session_${session_idx}.json"
                if [ -f "$output_file" ]; then
                    cat "$output_file" >> /tmp/timeline-data.js
                    # Add comma if not last session
                    if [ $session_idx -lt $((${#SESSION_LIST[@]} - 1)) ]; then
                        echo "," >> /tmp/timeline-data.js
                    fi
                fi
            done
            
            echo "  ]" >> /tmp/timeline-data.js
            echo "};" >> /tmp/timeline-data.js
            
            # Clear progress line
            printf "\r%*s\r" 80 ""
            
            
            # Start HTML document with CDN libraries
            cat > "$HTML_FILE" << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeline</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'sans': ['Inter', 'system-ui', '-apple-system', 'sans-serif'],
                        'mono': ['JetBrains Mono', 'monospace'],
                    },
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>
    <style>
        [x-cloak] { display: none !important; }
        .timeline-gradient { background: linear-gradient(180deg, #10b981 0%, #34d399 50%, #6ee7b7 100%); }
        .header-gradient { background: linear-gradient(135deg, #10b981 0%, #34d399 100%); }
        .timeline-marker-glow {
            box-shadow: 0 0 0 4px rgba(255,255,255,0.9), 0 0 0 6px rgba(16,185,129,0.3), 0 0 20px rgba(16,185,129,0.4);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-green-100 via-emerald-50 to-teal-100 min-h-screen p-4 md:p-8">
EOF
                # Use a script tag instead of inline x-data to avoid escaping issues
                cat >> "$HTML_FILE" << EOF
    <div id="timeline-app" class="max-w-7xl mx-auto relative">
    <script>
        document.addEventListener('alpine:init', () => {
            Alpine.data('timelineApp', () => ({
                activeSession: 0,
                totalSessions: ${#SESSION_LIST[@]},
                selectedTimeline: null,
                showDetails: {},
                showResumeModal: false,
                showTravelModal: false,
                modalSessionId: '',
                modalSessionCmd: '',
                modalTravelHash: '',
                modalTravelCmd: '',
                openResumeModal(sessionId) {
                    this.modalSessionId = sessionId;
                    this.modalSessionCmd = 'claude -r ' + sessionId;
                    this.showResumeModal = true;
                },
                openTravelModal(hash) {
                    this.modalTravelHash = hash;
                    this.modalTravelCmd = 'timeline travel ' + hash;
                    this.showTravelModal = true;
                },
                nextSession() {
                    if (this.activeSession < this.totalSessions - 1) {
                        this.activeSession++;
                        this.scrollToSession();
                    }
                },
                prevSession() {
                    if (this.activeSession > 0) {
                        this.activeSession--;
                        this.scrollToSession();
                    }
                },
                scrollToSession() {
                    setTimeout(() => {
                        const element = document.getElementById('session-' + this.activeSession);
                        if (element) element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 100);
                },
                copyCommand(text, event) {
                    navigator.clipboard.writeText(text);
                    const el = event.target;
                    const original = el.textContent;
                    el.textContent = '‚úì';
                    el.classList.add('!bg-green-600');
                    setTimeout(() => {
                        el.textContent = original;
                        el.classList.remove('!bg-green-600');
                    }, 1000);
                },
                renderCopyInput(text, placeholder = 'Click to select all') {
                    return \`
                        <div class="flex">
                            <button @click="copyCommand('\${text}', \$event)"
                                    class="px-3 py-3 bg-green-600 text-white rounded-l-lg hover:bg-green-700 transition-colors border border-green-600"
                                    title="Copy to clipboard">
                                üìã
                            </button>
                            <input type="text" value="\${text}" readonly
                                   class="flex-1 p-3 font-mono text-sm bg-gray-50 border-t border-b border-r border-gray-200 rounded-r-lg"
                                   onfocus="setTimeout(() => this.select(), 0)" title="\${placeholder}">
                        </div>
                    \`;
                },
                formatLocalTime(timestamp) {
                    const date = new Date(timestamp);
                    return date.toLocaleString();
                },
                formatUTCTime(timestamp) {
                    const date = new Date(timestamp);
                    return date.toISOString().replace('T', ' ').replace(/\\.\\d{3}Z/, ' UTC');
                }
            }))
        });
    </script>
    <div x-data="timelineApp">
EOF
                cat >> "$HTML_FILE" << 'EOF'
        <div class="bg-white rounded-3xl shadow-2xl overflow-hidden">
            <div class="header-gradient text-white p-8 md:p-12">
                <div class="flex items-center justify-center mb-4">
                    <svg class="w-12 h-12 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    <h1 class="text-4xl md:text-5xl font-bold">Timeline</h1>
                </div>
                <div class="text-center opacity-90 space-y-1">
EOF
                echo "                    <p class=\"text-sm\">üìÇ ${#SESSION_LIST[@]} Sessions</p>" >> "$HTML_FILE"
                cat >> "$HTML_FILE" << 'EOF'
                </div>
            </div>
            
            <div class="p-8 md:p-12">
                <!-- Session Accordion -->
                <div class="space-y-4">
EOF
                
                # Generate accordion for each session
                for session_idx in "${!SESSION_LIST[@]}"; do
                    session_id="${SESSION_LIST[$session_idx]}"
                    
                    # Show progress
                    show_progress $((session_idx + 1)) ${#SESSION_LIST[@]}
                    
                    # Get session info
                    session_file=""
                    for path in "$HOME/.claude/projects/-Users-steven-chong-Downloads-repos-timeline/${session_id}.jsonl" \
                                "$HOME/.claude/projects/"*"/${session_id}.jsonl"; do
                        if [ -f "$path" ]; then
                            session_file="$path"
                            break
                        fi
                    done
                    
                    # Get session create and modified datetimes
                    session_create_datetime="Unknown"
                    session_modified_datetime="Unknown"
                    
                    if [ -f "$session_file" ]; then
                        # Get first timestamp (creation) with time
                        first_timestamp=$(grep -m 1 '"timestamp"' "$session_file" 2>/dev/null | jq -r '.timestamp // empty' 2>/dev/null | head -1)
                        if [ -n "$first_timestamp" ]; then
                            # Format: 2024-01-15T14:30:22.123Z -> 2024-01-15 14:30
                            session_create_datetime=$(echo "$first_timestamp" | sed 's/T/ /' | cut -d'.' -f1 | cut -c1-16)
                        fi
                        
                        # Get last timestamp (modification) with time
                        last_timestamp=$(grep '"timestamp"' "$session_file" 2>/dev/null | tail -1 | jq -r '.timestamp // empty' 2>/dev/null)
                        if [ -n "$last_timestamp" ]; then
                            # Format: 2024-01-15T14:30:22.123Z -> 2024-01-15 14:30
                            session_modified_datetime=$(echo "$last_timestamp" | sed 's/T/ /' | cut -d'.' -f1 | cut -c1-16)
                        fi
                        
                        # Use file modification time as fallback with time
                        if [ "$session_modified_datetime" = "Unknown" ]; then
                            file_mod_time=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$session_file" 2>/dev/null)
                            if [ -n "$file_mod_time" ]; then
                                session_modified_datetime="$file_mod_time"
                            fi
                        fi
                        
                        # Use file creation time as fallback for create time
                        if [ "$session_create_datetime" = "Unknown" ]; then
                            file_create_time=$(stat -f "%SB" -t "%Y-%m-%d %H:%M" "$session_file" 2>/dev/null)
                            if [ -n "$file_create_time" ]; then
                                session_create_datetime="$file_create_time"
                            fi
                        fi
                    fi
                    
                    # Get timelines for this session
                    SESSION_TIMELINES=()
                    for timeline in "${ALL_TIMELINES[@]}"; do
                        commit_hash=$(git rev-parse "$timeline" 2>/dev/null)
                        if [ -n "$commit_hash" ]; then
                            notes=$(git notes --ref=timeline show "$commit_hash" 2>/dev/null || true)
                            if [ -n "$notes" ]; then
                                sid=$(echo "$notes" | grep "^Session-Id:" | cut -d' ' -f2- | head -1)
                                if [ "$sid" = "$session_id" ]; then
                                    SESSION_TIMELINES+=("$timeline")
                                fi
                            fi
                        fi
                    done
                    
                    # Accordion item
                    echo "                    <!-- Session $session_idx Accordion -->" >> "$HTML_FILE"
                    echo "                    <div id=\"session-$session_idx\" class=\"bg-white rounded-xl shadow-lg overflow-hidden\">" >> "$HTML_FILE"
                    echo "                        <!-- Accordion Header -->" >> "$HTML_FILE"
                    echo "                        <div @click=\"activeSession = activeSession === $session_idx ? -1 : $session_idx\"" >> "$HTML_FILE"
                    echo "                             class=\"p-6 cursor-pointer hover:bg-gray-50 transition-colors flex items-center justify-between\">" >> "$HTML_FILE"
                    echo "                            <div class=\"flex items-center gap-4 flex-1\">" >> "$HTML_FILE"
                    
                    # Navigation buttons group at the very front
                    echo "                                <div class=\"flex items-center gap-1\" @click.stop>" >> "$HTML_FILE"
                    
                    # Previous button (up arrow) - only if not first session
                    if [ $session_idx -gt 0 ]; then
                        echo "                                            <button @click.stop=\"activeSession = $((session_idx - 1)); scrollToSession()\"" >> "$HTML_FILE"
                        echo "                                                    class=\"p-1 bg-gray-100 text-gray-700 rounded hover:bg-gray-200 transition-colors\"" >> "$HTML_FILE"
                        echo "                                                    title=\"Previous Session\">" >> "$HTML_FILE"
                        echo "                                                <svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">" >> "$HTML_FILE"
                        echo "                                                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5 15l7-7 7 7\"/>" >> "$HTML_FILE"
                        echo "                                                </svg>" >> "$HTML_FILE"
                        echo "                                            </button>" >> "$HTML_FILE"
                    else
                        echo "                                            <button disabled class=\"p-1 bg-gray-50 text-gray-300 rounded cursor-not-allowed\">" >> "$HTML_FILE"
                        echo "                                                <svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">" >> "$HTML_FILE"
                        echo "                                                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5 15l7-7 7 7\"/>" >> "$HTML_FILE"
                        echo "                                                </svg>" >> "$HTML_FILE"
                        echo "                                            </button>" >> "$HTML_FILE"
                    fi
                    
                    # Next button (down arrow) - only if not last session  
                    if [ $session_idx -lt $((${#SESSION_LIST[@]} - 1)) ]; then
                        echo "                                            <button @click.stop=\"activeSession = $((session_idx + 1)); scrollToSession()\"" >> "$HTML_FILE"
                        echo "                                                    class=\"p-1 bg-gray-100 text-gray-700 rounded hover:bg-gray-200 transition-colors\"" >> "$HTML_FILE"
                        echo "                                                    title=\"Next Session\">" >> "$HTML_FILE"
                        echo "                                                <svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">" >> "$HTML_FILE"
                        echo "                                                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M19 9l-7 7-7-7\"/>" >> "$HTML_FILE"
                        echo "                                                </svg>" >> "$HTML_FILE"
                        echo "                                            </button>" >> "$HTML_FILE"
                    else
                        echo "                                            <button disabled class=\"p-1 bg-gray-50 text-gray-300 rounded cursor-not-allowed\">" >> "$HTML_FILE"
                        echo "                                                <svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">" >> "$HTML_FILE"
                        echo "                                                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M19 9l-7 7-7-7\"/>" >> "$HTML_FILE"
                        echo "                                                </svg>" >> "$HTML_FILE"
                        echo "                                            </button>" >> "$HTML_FILE"
                    fi
                    
                    echo "                                </div>" >> "$HTML_FILE"
                    
                    # Session info after navigation buttons
                    echo "                                <div class=\"flex-1\">" >> "$HTML_FILE"
                    echo "                                    <h3 class=\"text-lg font-semibold text-gray-900\">Session #$((session_idx + 1))</h3>" >> "$HTML_FILE"
                    echo "                                    <p class=\"text-xs text-gray-500 font-mono break-all\">$session_id</p>" >> "$HTML_FILE"
                    echo "                                    <p class=\"text-xs text-gray-500\">üìÖ Created: <span x-text=\"formatLocalTime('$session_create_datetime')\" :title=\"formatUTCTime('$session_create_datetime')\" class=\"cursor-help\"></span></p>" >> "$HTML_FILE"
                    echo "                                    <p class=\"text-xs text-gray-500\">üïí Modified: <span x-text=\"formatLocalTime('$session_modified_datetime')\" :title=\"formatUTCTime('$session_modified_datetime')\" class=\"cursor-help\"></span></p>" >> "$HTML_FILE"
                    echo "                                </div>" >> "$HTML_FILE"
                    
                    # Right side badges and buttons
                    echo "                                <div class=\"flex items-center gap-2\">" >> "$HTML_FILE"
                    
                    # Timeline count badge
                    if [ ${#SESSION_TIMELINES[@]} -gt 0 ]; then
                        echo "                                    <span class=\"px-3 py-1 bg-green-100 text-green-700 rounded-full text-sm font-medium\">" >> "$HTML_FILE"
                        echo "                                        ${#SESSION_TIMELINES[@]} timelines" >> "$HTML_FILE"
                        echo "                                    </span>" >> "$HTML_FILE"
                    else
                        echo "                                    <span class=\"px-3 py-1 bg-gray-100 text-gray-500 rounded-full text-sm font-medium\">" >> "$HTML_FILE"
                        echo "                                        No timelines yet" >> "$HTML_FILE"
                        echo "                                    </span>" >> "$HTML_FILE"
                    fi
                    
                    # Resume button with modal  
                    echo "                                    <button @click.stop=\"openResumeModal('$session_id')\"" >> "$HTML_FILE"
                    echo "                                            class=\"px-3 py-1 bg-green-100 text-green-700 rounded-full text-sm font-medium hover:bg-green-200 transition-colors\">" >> "$HTML_FILE"
                    echo "                                        üìã Resume" >> "$HTML_FILE"
                    echo "                                    </button>" >> "$HTML_FILE"
                    echo "                                </div>" >> "$HTML_FILE"
                    echo "                            </div>" >> "$HTML_FILE"
                    echo "                            <svg :class=\"activeSession === $session_idx ? 'rotate-180' : ''\"" >> "$HTML_FILE"
                    echo "                                 class=\"w-6 h-6 text-gray-400 transition-transform\"" >> "$HTML_FILE"
                    echo "                                 fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">" >> "$HTML_FILE"
                    echo "                                <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M19 9l-7 7-7-7\"/>" >> "$HTML_FILE"
                    echo "                            </svg>" >> "$HTML_FILE"
                    echo "                        </div>" >> "$HTML_FILE"
                    
                    # Accordion content
                    echo "                        <!-- Accordion Content -->" >> "$HTML_FILE"
                    echo "                        <div x-show=\"activeSession === $session_idx\" x-cloak class=\"border-t border-gray-100\">" >> "$HTML_FILE"
                    echo "                            <div class=\"p-6\">" >> "$HTML_FILE"
                    
                    # Session-level tabs and content
                    echo "                                <!-- Session Tabs -->" >> "$HTML_FILE"
                    echo "                                <div x-data=\"{ sessionTab: 'timelines' }\" class=\"mt-6\">" >> "$HTML_FILE"
                    echo "                                    <!-- Session Tab Navigation -->" >> "$HTML_FILE"
                    echo "                                    <div class=\"flex border-b border-gray-200 mb-6\">" >> "$HTML_FILE"
                    echo "                                        <button @click=\"sessionTab = 'timelines'\" " >> "$HTML_FILE"
                    echo "                                                :class=\"sessionTab === 'timelines' ? 'border-green-500 text-green-600' : 'border-transparent text-gray-500 hover:text-gray-700'\"" >> "$HTML_FILE"
                    echo "                                                class=\"px-6 py-3 border-b-2 font-medium text-sm transition-colors\">" >> "$HTML_FILE"
                    echo "                                            ‚è∞ Timelines (${#SESSION_TIMELINES[@]})" >> "$HTML_FILE"
                    echo "                                        </button>" >> "$HTML_FILE"
                    echo "                                        <button @click=\"sessionTab = 'files'\" " >> "$HTML_FILE"
                    echo "                                                :class=\"sessionTab === 'files' ? 'border-green-500 text-green-600' : 'border-transparent text-gray-500 hover:text-gray-700'\"" >> "$HTML_FILE"
                    echo "                                                class=\"px-6 py-3 border-b-2 font-medium text-sm transition-colors\">" >> "$HTML_FILE"
                    echo "                                            üìÅ All Files Changed" >> "$HTML_FILE"
                    echo "                                        </button>" >> "$HTML_FILE"
                    echo "                                        <button @click=\"sessionTab = 'diff'\" " >> "$HTML_FILE"
                    echo "                                                :class=\"sessionTab === 'diff' ? 'border-green-500 text-green-600' : 'border-transparent text-gray-500 hover:text-gray-700'\"" >> "$HTML_FILE"
                    echo "                                                class=\"px-6 py-3 border-b-2 font-medium text-sm transition-colors\">" >> "$HTML_FILE"
                    echo "                                            üîç Full Session Diff" >> "$HTML_FILE"
                    echo "                                        </button>" >> "$HTML_FILE"
                    echo "                                        <button @click=\"sessionTab = 'transcript'\" " >> "$HTML_FILE"
                    echo "                                                :class=\"sessionTab === 'transcript' ? 'border-green-500 text-green-600' : 'border-transparent text-gray-500 hover:text-gray-700'\"" >> "$HTML_FILE"
                    echo "                                                class=\"px-6 py-3 border-b-2 font-medium text-sm transition-colors\">" >> "$HTML_FILE"
                    echo "                                            üí¨ Full Transcript" >> "$HTML_FILE"
                    echo "                                        </button>" >> "$HTML_FILE"
                    echo "                                    </div>" >> "$HTML_FILE"
                    echo "                                    " >> "$HTML_FILE"
                    echo "                                    <!-- Timelines Tab -->" >> "$HTML_FILE"
                    echo "                                    <div x-show=\"sessionTab === 'timelines'\">" >> "$HTML_FILE"
                    
                    # Only show timeline content if there are timelines
                    if [ ${#SESSION_TIMELINES[@]} -gt 0 ]; then
                        echo "                                        <!-- Timeline Content -->" >> "$HTML_FILE"
                        echo "                                        <div class=\"relative\">" >> "$HTML_FILE"
                        echo "                                    <!-- Vertical Line -->" >> "$HTML_FILE"
                        echo "                                    <div class=\"absolute left-8 top-0 bottom-0 w-0.5 timeline-gradient\"></div>" >> "$HTML_FILE"
                        
                        # Generate timeline items for this session
                        for ((i=${#SESSION_TIMELINES[@]}-1; i>=0; i--)); do
                        DISPLAY_INDEX=$((${#SESSION_TIMELINES[@]} - 1 - i))
                        BRANCH="${SESSION_TIMELINES[$i]}"
                    
                    commit_hash=$(git rev-parse "$BRANCH" 2>/dev/null)
                    short_hash=$(git rev-parse --short "$BRANCH" 2>/dev/null)
                    commit_time=$(git log -1 --pretty=format:"%cr" "$BRANCH" 2>/dev/null)
                    commit_date=$(git log -1 --pretty=format:"%ci" "$BRANCH" 2>/dev/null)
                    commit_msg=$(git log -1 --pretty=format:"%s" "$BRANCH" 2>/dev/null)
                    
                    # Truncate message for preview
                    if [ ${#commit_msg} -gt 60 ]; then
                        commit_preview="${commit_msg:0:60}..."
                    else
                        commit_preview="$commit_msg"
                    fi
                    
                    # Get file statistics
                    STATS=$(git diff --shortstat HEAD "$BRANCH" 2>/dev/null | sed 's/files\? changed/files/')
                    files_changed=$(echo "$STATS" | grep -oE '[0-9]+ file' | grep -o '[0-9]*' | head -1)
                    additions=$(echo "$STATS" | grep -oE '[0-9]+ insertion' | grep -o '[0-9]*' | head -1)
                    deletions=$(echo "$STATS" | grep -oE '[0-9]+ deletion' | grep -o '[0-9]*' | head -1)
                    
                    # Get changed files
                    changed_files=$(git diff --name-status HEAD "$BRANCH" 2>/dev/null)
                    file_count=$(echo "$changed_files" | wc -l | tr -d ' ')
                    
                    echo "                    <!-- Timeline Item #$DISPLAY_INDEX -->" >> "$HTML_FILE"
                    echo "                    <div x-data=\"{ expanded: false }\" class=\"relative mb-8 ml-12\">" >> "$HTML_FILE"
                    echo "                        <!-- Marker -->" >> "$HTML_FILE"
                    echo "                        <div @click=\"expanded = !expanded\" class=\"absolute -left-[2.75rem] w-6 h-6 bg-white rounded-full border-4 border-green-500 timeline-marker-glow cursor-pointer hover:scale-110 transition-transform\" title=\"Click to expand/collapse\"></div>" >> "$HTML_FILE"
                    echo "                        " >> "$HTML_FILE"
                    echo "                        <!-- Content Card -->" >> "$HTML_FILE"
                    echo "                        <div class=\"bg-white rounded-xl shadow-lg hover:shadow-xl transition-shadow border border-gray-100\">" >> "$HTML_FILE"
                    echo "                            <!-- Header (Always Visible) -->" >> "$HTML_FILE"
                    echo "                            <div @click=\"expanded = !expanded\" class=\"p-4 cursor-pointer hover:bg-gray-50 transition-colors rounded-t-xl\">" >> "$HTML_FILE"
                    echo "                                <div class=\"flex items-start justify-between\">" >> "$HTML_FILE"
                    echo "                                    <div class=\"flex-1\">" >> "$HTML_FILE"
                    echo "                                        <div class=\"flex items-center gap-2 text-sm text-gray-500 mb-1\">" >> "$HTML_FILE"
                    echo "                                            <span>‚è∞ $commit_time</span>" >> "$HTML_FILE"
                    echo "                                            <span class=\"text-xs px-2 py-0.5 bg-green-100 text-green-700 rounded-full font-medium\">#$DISPLAY_INDEX</span>" >> "$HTML_FILE"
                    echo "                                        </div>" >> "$HTML_FILE"
                    echo "                                        <h3 class=\"font-semibold text-gray-900\">$commit_preview</h3>" >> "$HTML_FILE"
                    echo "                                        <div class=\"flex items-center gap-4 mt-2 text-sm\">" >> "$HTML_FILE"
                    echo "                                            <span class=\"text-gray-600\">üìÅ ${files_changed:-0} files</span>" >> "$HTML_FILE"
                    echo "                                            <span class=\"text-green-600\">+${additions:-0}</span>" >> "$HTML_FILE"
                    echo "                                            <span class=\"text-red-600\">-${deletions:-0}</span>" >> "$HTML_FILE"
                    echo "                                            <span class=\"font-mono text-xs bg-gray-100 px-2 py-1 rounded\">$short_hash</span>" >> "$HTML_FILE"
                    echo "                                        </div>" >> "$HTML_FILE"
                    echo "                                    </div>" >> "$HTML_FILE"
                    echo "                                    <svg :class=\"expanded ? 'rotate-180' : ''\" class=\"w-5 h-5 text-gray-400 transition-transform\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">" >> "$HTML_FILE"
                    echo "                                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M19 9l-7 7-7-7\"/>" >> "$HTML_FILE"
                    echo "                                    </svg>" >> "$HTML_FILE"
                    echo "                                </div>" >> "$HTML_FILE"
                    echo "                            </div>" >> "$HTML_FILE"
                    echo "                            " >> "$HTML_FILE"
                    echo "                            <!-- Expandable Details -->" >> "$HTML_FILE"
                    echo "                            <div x-show=\"expanded\" x-collapse x-cloak class=\"border-t border-gray-100\">" >> "$HTML_FILE"
                    echo "                                <!-- Tab Navigation -->" >> "$HTML_FILE"
                    echo "                                <div x-data=\"{ activeTab: 'files' }\" class=\"p-4\">" >> "$HTML_FILE"
                    echo "                                    <div class=\"flex border-b border-gray-200 mb-4\">" >> "$HTML_FILE"
                    echo "                                        <button @click=\"activeTab = 'files'\" " >> "$HTML_FILE"
                    echo "                                                :class=\"activeTab === 'files' ? 'border-green-500 text-green-600' : 'border-transparent text-gray-500 hover:text-gray-700'\"" >> "$HTML_FILE"
                    echo "                                                class=\"px-4 py-2 border-b-2 font-medium text-sm transition-colors\">" >> "$HTML_FILE"
                    echo "                                            üìÅ Files Changed" >> "$HTML_FILE"
                    echo "                                        </button>" >> "$HTML_FILE"
                    echo "                                        <button @click=\"activeTab = 'diff'\" " >> "$HTML_FILE"
                    echo "                                                :class=\"activeTab === 'diff' ? 'border-green-500 text-green-600' : 'border-transparent text-gray-500 hover:text-gray-700'\"" >> "$HTML_FILE"
                    echo "                                                class=\"px-4 py-2 border-b-2 font-medium text-sm transition-colors\">" >> "$HTML_FILE"
                    echo "                                            üîç Full Diff" >> "$HTML_FILE"
                    echo "                                        </button>" >> "$HTML_FILE"
                    echo "                                        <button @click=\"activeTab = 'transcript'\" " >> "$HTML_FILE"
                    echo "                                                :class=\"activeTab === 'transcript' ? 'border-green-500 text-green-600' : 'border-transparent text-gray-500 hover:text-gray-700'\"" >> "$HTML_FILE"
                    echo "                                                class=\"px-4 py-2 border-b-2 font-medium text-sm transition-colors\">" >> "$HTML_FILE"
                    echo "                                            üí¨ Transcript" >> "$HTML_FILE"
                    echo "                                        </button>" >> "$HTML_FILE"
                    echo "                                    </div>" >> "$HTML_FILE"
                    echo "                                    " >> "$HTML_FILE"
                    echo "                                    <!-- Files Tab -->" >> "$HTML_FILE"
                    echo "                                    <div x-show=\"activeTab === 'files'\" class=\"space-y-3\">" >> "$HTML_FILE"
                    
                    # Full commit message if different from preview
                    if [ "$commit_msg" != "$commit_preview" ]; then
                        echo "                                    <div class=\"text-sm text-gray-700 p-3 bg-gray-50 rounded-lg\">" >> "$HTML_FILE"
                        echo "                                        <p class=\"font-medium mb-1\">Full Message:</p>" >> "$HTML_FILE"
                        echo "                                        <p>$commit_msg</p>" >> "$HTML_FILE"
                        echo "                                    </div>" >> "$HTML_FILE"
                    fi
                    
                    echo "                                    <div class=\"text-sm text-gray-700\">" >> "$HTML_FILE"
                    echo "                                        <p class=\"font-medium mb-2\">Changed Files ($file_count):</p>" >> "$HTML_FILE"
                    echo "                                        <div class=\"max-h-48 overflow-y-auto space-y-1\">" >> "$HTML_FILE"
                    
                    if [ -n "$changed_files" ]; then
                        echo "$changed_files" | while IFS=$'\t' read -r status file; do
                            if [ -n "$file" ]; then
                                case "$status" in
                                    A) badge_class="bg-green-100 text-green-700" status_text="Added" ;;
                                    M) badge_class="bg-yellow-100 text-yellow-700" status_text="Modified" ;;
                                    D) badge_class="bg-red-100 text-red-700" status_text="Deleted" ;;
                                    *) badge_class="bg-gray-100 text-gray-700" status_text="$status" ;;
                                esac
                                echo "                                            <div class=\"flex items-center gap-2 font-mono text-xs\">" >> "$HTML_FILE"
                                echo "                                                <span class=\"px-1.5 py-0.5 rounded $badge_class\">$status_text</span>" >> "$HTML_FILE"
                                echo "                                                <span class=\"text-gray-600\">$file</span>" >> "$HTML_FILE"
                                echo "                                            </div>" >> "$HTML_FILE"
                            fi
                        done
                    fi
                    
                    echo "                                        </div>" >> "$HTML_FILE"
                    echo "                                    </div>" >> "$HTML_FILE"
                    echo "                                    </div>" >> "$HTML_FILE"
                    echo "                                    " >> "$HTML_FILE"
                    echo "                                    <!-- Full Diff Tab -->" >> "$HTML_FILE"
                    echo "                                    <div x-show=\"activeTab === 'diff'\" class=\"space-y-3\">" >> "$HTML_FILE"
                    echo "                                        <div class=\"text-sm text-gray-700\">" >> "$HTML_FILE"
                    echo "                                            <p class=\"font-medium mb-2\">Full Diff View:</p>" >> "$HTML_FILE"
                    echo "                                            <div class=\"bg-gray-900 text-gray-100 p-4 rounded-lg font-mono text-xs overflow-x-auto max-h-96 overflow-y-auto\">" >> "$HTML_FILE"
                    
                    # Generate diff content
                    diff_content=$(git diff HEAD "$BRANCH" 2>/dev/null | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g; s/"/\&quot;/g')
                    if [ -n "$diff_content" ]; then
                        echo "                                                <pre>$diff_content</pre>" >> "$HTML_FILE"
                    else
                        echo "                                                <p class=\"text-gray-400\">No diff available</p>" >> "$HTML_FILE"
                    fi
                    
                    echo "                                            </div>" >> "$HTML_FILE"
                    echo "                                        </div>" >> "$HTML_FILE"
                    echo "                                    </div>" >> "$HTML_FILE"
                    echo "                                    " >> "$HTML_FILE"
                    echo "                                    <!-- Transcript Tab -->" >> "$HTML_FILE"
                    echo "                                    <div x-show=\"activeTab === 'transcript'\" class=\"space-y-3\">" >> "$HTML_FILE"
                    echo "                                        <div class=\"text-sm text-gray-700\">" >> "$HTML_FILE"
                    echo "                                            <p class=\"font-medium mb-2\">Session Transcript:</p>" >> "$HTML_FILE"
                    echo "                                            <div class=\"bg-gray-50 p-4 rounded-lg max-h-96 overflow-y-auto\">" >> "$HTML_FILE"
                    
                    # Generate transcript content from session file
                    if [ -f "$session_file" ] && command -v jq >/dev/null 2>&1; then
                        # Extract recent messages from session
                        echo "                                                <!-- Recent session messages -->" >> "$HTML_FILE"
                        # Use temp file to avoid subshell issues
                        temp_msgs=$(mktemp)
                        grep '"role"' "$session_file" | tail -10 > "$temp_msgs" 2>/dev/null || true
                        while read -r line; do
                            msg_role=$(echo "$line" | jq -r '.role' 2>/dev/null)
                            msg_content=$(echo "$line" | jq -r '.content' 2>/dev/null | head -c 200 | sed 's/"/\\"/g')
                            if [ -n "$msg_role" ] && [ -n "$msg_content" ]; then
                                case "$msg_role" in
                                    "user") 
                                        echo "                                                <div class=\"mb-2 p-2 bg-blue-100 rounded\"><strong>üë§ User:</strong> $msg_content...</div>" >> "$HTML_FILE"
                                        ;;
                                    "assistant") 
                                        echo "                                                <div class=\"mb-2 p-2 bg-green-100 rounded\"><strong>ü§ñ Assistant:</strong> $msg_content...</div>" >> "$HTML_FILE"
                                        ;;
                                esac
                            fi
                        done < "$temp_msgs"
                        rm -f "$temp_msgs"
                    else
                        echo "                                                <p class=\"text-gray-400\">Transcript data not available or jq not installed</p>" >> "$HTML_FILE"
                    fi
                    
                    echo "                                            </div>" >> "$HTML_FILE"
                    echo "                                        </div>" >> "$HTML_FILE"
                    echo "                                    </div>" >> "$HTML_FILE"
                    echo "                                    " >> "$HTML_FILE"
                    echo "                                    <!-- Travel Button -->" >> "$HTML_FILE"
                    echo "                                    <div class=\"pt-3 border-t border-gray-100\">" >> "$HTML_FILE"
                    echo "                                        <button @click=\"openTravelModal('$short_hash')\"" >> "$HTML_FILE"
                    echo "                                                class=\"px-4 py-2 bg-blue-100 text-blue-700 rounded-lg hover:bg-blue-200 transition-colors font-medium text-sm\">" >> "$HTML_FILE"
                    echo "                                            ‚è∞ Time Travel to This Point" >> "$HTML_FILE"
                    echo "                                        </button>" >> "$HTML_FILE"
                    echo "                                    </div>" >> "$HTML_FILE"
                    echo "                                </div>" >> "$HTML_FILE"
                    echo "                            </div>" >> "$HTML_FILE"
                    echo "                        </div>" >> "$HTML_FILE"
                    echo "                    </div>" >> "$HTML_FILE"
                        done
                        
                        # Close timeline content div
                        echo "                                        </div>" >> "$HTML_FILE"
                    else
                        echo "                                        <div class=\"text-center py-8 text-gray-500\">" >> "$HTML_FILE"
                        echo "                                            <p>No timelines in this session yet</p>" >> "$HTML_FILE"
                        echo "                                        </div>" >> "$HTML_FILE"
                    fi
                    echo "                                    </div>" >> "$HTML_FILE"
                    echo "                                    " >> "$HTML_FILE"
                    
                    # Add other session-level tabs
                    echo "                                    <!-- All Files Changed Tab -->" >> "$HTML_FILE"
                    echo "                                    <div x-show=\"sessionTab === 'files'\" class=\"space-y-4\">" >> "$HTML_FILE"
                    echo "                                        <div class=\"bg-white rounded-lg border border-gray-200 p-6\">" >> "$HTML_FILE"
                    echo "                                            <h3 class=\"font-semibold text-gray-900 mb-4\">All Files Changed in This Session</h3>" >> "$HTML_FILE"
                    
                    # Collect all changed files across all timelines in this session
                    if [ ${#SESSION_TIMELINES[@]} -gt 0 ]; then
                        echo "                                            <div class=\"space-y-2 max-h-96 overflow-y-auto\">" >> "$HTML_FILE"
                        
                        # Get all unique files changed across timelines
                        for timeline_branch in "${SESSION_TIMELINES[@]}"; do
                            changed_files=$(git diff --name-status HEAD "$timeline_branch" 2>/dev/null)
                            if [ -n "$changed_files" ]; then
                                # Use a temporary file to avoid subshell issues
                                temp_file=$(mktemp)
                                echo "$changed_files" > "$temp_file"
                                while IFS=$'\t' read -r status file; do
                                    if [ -n "$file" ]; then
                                        case "$status" in
                                            A) badge_class="bg-green-100 text-green-700" status_text="Added" ;;
                                            M) badge_class="bg-yellow-100 text-yellow-700" status_text="Modified" ;;
                                            D) badge_class="bg-red-100 text-red-700" status_text="Deleted" ;;
                                            *) badge_class="bg-gray-100 text-gray-700" status_text="$status" ;;
                                        esac
                                        echo "                                                <div class=\"flex items-center justify-between p-3 bg-gray-50 rounded-lg\">" >> "$HTML_FILE"
                                        echo "                                                    <span class=\"font-mono text-sm\">üìÑ $file</span>" >> "$HTML_FILE"
                                        echo "                                                    <span class=\"px-2 py-1 text-xs rounded-full $badge_class\">$status_text</span>" >> "$HTML_FILE"
                                        echo "                                                </div>" >> "$HTML_FILE"
                                    fi
                                done < "$temp_file"
                                rm -f "$temp_file"
                            fi
                        done
                        
                        echo "                                            </div>" >> "$HTML_FILE"
                    else
                        echo "                                            <p class=\"text-gray-500\">No files changed in this session</p>" >> "$HTML_FILE"
                    fi
                    echo "                                        </div>" >> "$HTML_FILE"
                    echo "                                    </div>" >> "$HTML_FILE"
                    echo "                                    " >> "$HTML_FILE"
                    
                    echo "                                    <!-- Full Session Diff Tab -->" >> "$HTML_FILE"
                    echo "                                    <div x-show=\"sessionTab === 'diff'\" class=\"space-y-4\">" >> "$HTML_FILE"
                    echo "                                        <div class=\"bg-white rounded-lg border border-gray-200 p-6\">" >> "$HTML_FILE"
                    echo "                                            <h3 class=\"font-semibold text-gray-900 mb-4\">Complete Session Diff</h3>" >> "$HTML_FILE"
                    echo "                                            <div class=\"bg-gray-900 text-gray-100 p-4 rounded-lg font-mono text-xs overflow-x-auto max-h-96 overflow-y-auto\">" >> "$HTML_FILE"
                    
                    # Generate combined diff for all timelines in session
                    if [ ${#SESSION_TIMELINES[@]} -gt 0 ]; then
                        # Get the earliest timeline to compare against
                        earliest_timeline="${SESSION_TIMELINES[$((${#SESSION_TIMELINES[@]} - 1))]}"
                        session_diff=$(git diff HEAD "$earliest_timeline" 2>/dev/null | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g; s/"/\&quot;/g')
                        if [ -n "$session_diff" ]; then
                            echo "                                                <pre>$session_diff</pre>" >> "$HTML_FILE"
                        else
                            echo "                                                <p class=\"text-gray-400\">No diff available</p>" >> "$HTML_FILE"
                        fi
                    else
                        echo "                                                <p class=\"text-gray-400\">No timelines in this session</p>" >> "$HTML_FILE"
                    fi
                    
                    echo "                                            </div>" >> "$HTML_FILE"
                    echo "                                        </div>" >> "$HTML_FILE"
                    echo "                                    </div>" >> "$HTML_FILE"
                    echo "                                    " >> "$HTML_FILE"
                    
                    echo "                                    <!-- Full Session Transcript Tab -->" >> "$HTML_FILE"
                    echo "                                    <div x-show=\"sessionTab === 'transcript'\" class=\"space-y-4\">" >> "$HTML_FILE"
                    echo "                                        <div class=\"bg-white rounded-lg border border-gray-200 p-6\">" >> "$HTML_FILE"
                    echo "                                            <h3 class=\"font-semibold text-gray-900 mb-4\">Complete Session Transcript</h3>" >> "$HTML_FILE"
                    echo "                                            <div class=\"bg-gray-50 p-4 rounded-lg max-h-96 overflow-y-auto space-y-3\">" >> "$HTML_FILE"
                    
                    # Generate full session transcript
                    if [ -f "$session_file" ] && command -v jq >/dev/null 2>&1; then
                        echo "                                                <!-- Full session messages -->" >> "$HTML_FILE"
                        # Use a temporary file to avoid subshell issues
                        temp_transcript=$(mktemp)
                        grep '"role"' "$session_file" > "$temp_transcript" 2>/dev/null || true
                        while read -r line; do
                            msg_role=$(echo "$line" | jq -r '.role' 2>/dev/null)
                            msg_content=$(echo "$line" | jq -r '.content' 2>/dev/null | head -c 300 | sed 's/"/\\"/g')
                            if [ -n "$msg_role" ] && [ -n "$msg_content" ]; then
                                case "$msg_role" in
                                    "user") 
                                        echo "                                                <div class=\"p-3 bg-blue-50 border-l-4 border-blue-400 rounded-r-lg\">" >> "$HTML_FILE"
                                        echo "                                                    <div class=\"flex items-start gap-3\">" >> "$HTML_FILE"
                                        echo "                                                        <span class=\"text-blue-600 font-semibold\">üë§ User:</span>" >> "$HTML_FILE"
                                        echo "                                                        <div class=\"text-sm text-gray-700 flex-1\">$msg_content...</div>" >> "$HTML_FILE"
                                        echo "                                                    </div>" >> "$HTML_FILE"
                                        echo "                                                </div>" >> "$HTML_FILE"
                                        ;;
                                    "assistant") 
                                        echo "                                                <div class=\"p-3 bg-green-50 border-l-4 border-green-400 rounded-r-lg\">" >> "$HTML_FILE"
                                        echo "                                                    <div class=\"flex items-start gap-3\">" >> "$HTML_FILE"
                                        echo "                                                        <span class=\"text-green-600 font-semibold\">ü§ñ Assistant:</span>" >> "$HTML_FILE"
                                        echo "                                                        <div class=\"text-sm text-gray-700 flex-1\">$msg_content...</div>" >> "$HTML_FILE"
                                        echo "                                                    </div>" >> "$HTML_FILE"
                                        echo "                                                </div>" >> "$HTML_FILE"
                                        ;;
                                esac
                            fi
                        done < "$temp_transcript"
                        rm -f "$temp_transcript"
                    else
                        echo "                                                <p class=\"text-gray-400\">Session transcript not available or jq not installed</p>" >> "$HTML_FILE"
                    fi
                    
                    echo "                                            </div>" >> "$HTML_FILE"
                    echo "                                        </div>" >> "$HTML_FILE"
                    echo "                                    </div>" >> "$HTML_FILE"
                    echo "                                </div>" >> "$HTML_FILE"
                    
                    # Close accordion content divs
                    echo "                            </div>" >> "$HTML_FILE"
                    echo "                        </div>" >> "$HTML_FILE"
                    echo "                    </div>" >> "$HTML_FILE"
                done
                
                # Clear the progress line
                printf "\r%*s\r" 80 ""
                
                cat >> "$HTML_FILE" << 'EOF'
            </div>
        </div>
        
        <!-- Resume Session Modal -->
        <div x-show="showResumeModal" 
             x-cloak
             class="fixed inset-0 z-50 flex items-center justify-center"
             style="background-color: rgba(0,0,0,0.5);">
            <div @click.away="showResumeModal = false"
                 class="bg-white rounded-xl shadow-2xl border border-gray-200 p-6 max-w-md w-full mx-4">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-lg font-semibold text-gray-900">Resume Session</h3>
                    <button @click="showResumeModal = false" 
                            class="text-gray-400 hover:text-gray-600 transition-colors">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
                
                <p class="text-sm text-gray-600 mb-4">Copy this command to resume the session:</p>
                
                <div class="mb-4" x-html="renderCopyInput(modalSessionCmd, 'Focus to select all')"></div>
                
                <div class="flex gap-3">
                    <button @click="navigator.clipboard.writeText(modalSessionCmd); showResumeModal = false" 
                            class="flex-1 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors font-medium">
                        üìã Copy & Close
                    </button>
                    <button @click="showResumeModal = false" 
                            class="flex-1 px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors font-medium">
                        ‚úï Close
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Travel Modal -->
        <div x-show="showTravelModal" 
             x-cloak
             class="fixed inset-0 z-50 flex items-center justify-center"
             style="background-color: rgba(0,0,0,0.5);">
            <div @click.away="showTravelModal = false"
                 class="bg-white rounded-xl shadow-2xl border border-gray-200 p-6 max-w-md w-full mx-4">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-lg font-semibold text-gray-900">Time Travel</h3>
                    <button @click="showTravelModal = false" 
                            class="text-gray-400 hover:text-gray-600 transition-colors">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
                
                <p class="text-sm text-gray-600 mb-4">Copy this command to travel to this timeline:</p>
                
                <div class="mb-4" x-html="renderCopyInput(modalTravelCmd, 'Focus to select all')"></div>
                
                <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-3 mb-4">
                    <p class="text-xs text-yellow-800">
                        <strong>‚ö†Ô∏è Warning:</strong> This will change your working directory files to match this timeline snapshot.
                    </p>
                </div>
                
                <div class="flex gap-3">
                    <button @click="navigator.clipboard.writeText(modalTravelCmd); showTravelModal = false" 
                            class="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium">
                        üìã Copy & Close
                    </button>
                    <button @click="showTravelModal = false" 
                            class="flex-1 px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors font-medium">
                        ‚úï Close
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    </div>  <!-- Close x-data div -->
    </div>  <!-- Close timeline-app div -->
</body>
</html>
EOF
                
                echo "‚ú® HTML timeline generated: $HTML_FILE"
                echo ""
                echo "‚úÖ Timeline view generated successfully!"
                echo ""
                
                # Open in browser
                if command -v open &> /dev/null; then
                    open "$HTML_FILE"
                    echo "üìä Opened in browser: $HTML_FILE"
                elif command -v xdg-open &> /dev/null; then
                    xdg-open "$HTML_FILE"
                    echo "üìä Opened in browser: $HTML_FILE"
                else
                    echo "üìä View saved to: $HTML_FILE"
                    echo "üìù Open this file in a browser to view the timeline"
                fi
            ;;
        "browse")
            # Browse diffs using Git's configured diff tool
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null)
            
            # Get all timeline branches and filter out those identical to HEAD
            ALL_TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/*" 2>/dev/null))
            TIMELINES=()
            
            # Filter out timelines that are identical to HEAD
            for timeline in "${ALL_TIMELINES[@]}"; do
                if [ -n "$(git diff --name-only HEAD "$timeline" 2>/dev/null)" ]; then
                    TIMELINES+=("$timeline")
                fi
            done
            
            if [ ${#TIMELINES[@]} -eq 0 ]; then
                echo "No timelines with changes found."
                exit 0
            fi
            
            # Check if difftool is configured
            DIFF_TOOL=$(git config diff.tool 2>/dev/null)
            if [ -z "$DIFF_TOOL" ]; then
                echo "‚ö†Ô∏è  No diff tool configured. Set one with:"
                echo "   git config --global diff.tool <tool>"
                echo "   Popular options: vscode, meld, vimdiff, opendiff"
                echo ""
                echo "Falling back to terminal diff view..."
                echo ""
            fi
            
            # Interactive timeline selection for difftool
            echo "üîß Git Diff Tool Browser"
            echo "========================"
            if ! display_timeline "$CURRENT_BRANCH" "$CURRENT_HEAD"; then
                exit 0
            fi
            echo ""
            
            while true; do
                read -p "Select timeline number to open in diff tool (or press Enter to exit): " TIMELINE_NUM
                
                if [ -z "$TIMELINE_NUM" ]; then
                    echo "Exiting browse mode."
                    exit 0
                fi
                
                if [ "$TIMELINE_NUM" -lt 0 ] || [ "$TIMELINE_NUM" -ge "${#TIMELINES[@]}" ] 2>/dev/null; then
                    echo "Invalid selection. Please choose 0-$((${#TIMELINES[@]} - 1))"
                    echo ""
                    continue
                fi
                
                # Convert display index to array index
                ARRAY_INDEX=$((${#TIMELINES[@]} - 1 - TIMELINE_NUM))
                BRANCH="${TIMELINES[$ARRAY_INDEX]}"
                
                echo ""
                echo "Opening timeline #$TIMELINE_NUM in diff tool..."
                
                if [ -n "$DIFF_TOOL" ]; then
                    # Get changed files
                    changed_files=$(git diff --name-only HEAD "$BRANCH" 2>/dev/null)
                    if [ -n "$changed_files" ]; then
                        file_count=$(echo "$changed_files" | wc -l | tr -d ' ')
                        echo "Changed files ($file_count):"
                        echo "$changed_files" | nl -w2 -s') '
                        echo ""
                        
                        case "$DIFF_TOOL" in
                            "cursor")
                                # Cursor: let user select which file to diff
                                echo "Select file to view in Cursor:"
                                echo ""
                                
                                # For Cursor, use git difftool with each file
                                echo "$changed_files" | while IFS= read -r file; do
                                    echo "üìÑ Opening: $file"
                                    git difftool --no-prompt HEAD "$BRANCH" -- "$file"
                                done
                                ;;
                            *)
                                # Default: use standard git difftool
                                git difftool --no-prompt HEAD "$BRANCH"
                                ;;
                        esac
                    else
                        # No difftool configured, show text diff
                        git diff HEAD "$BRANCH"
                    fi
                fi
                echo ""
            done
            ;;
        "travel")
            # Interactive timeline travel with resume input box UI
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null)
            
            # Get all timeline branches
            ALL_TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-'))
            
            if [ ${#ALL_TIMELINES[@]} -eq 0 ]; then
                echo "No timelines found for branch '$CURRENT_BRANCH'."
                exit 0
            fi
            
            echo "üöÄ Timeline Travel"
            echo "================="
            echo ""
            
            # Display timelines with index numbers (newest first)
            for ((i=0; i<${#ALL_TIMELINES[@]}; i++)); do
                BRANCH="${ALL_TIMELINES[$i]}"
                commit_time=$(git log -1 --pretty=format:"%cr" "$BRANCH" 2>/dev/null)
                commit_msg=$(git log -1 --pretty=format:"%s" "$BRANCH" 2>/dev/null | head -c 60)
                printf "  %2d) %-15s %s\n" "$i" "($commit_time)" "$commit_msg"
            done
            echo ""
            
            # Interactive travel selection
            while true; do
                read -p "Select timeline number to travel to (or press Enter to cancel): " TIMELINE_NUM
                
                if [ -z "$TIMELINE_NUM" ]; then
                    echo "Cancelled."
                    exit 0
                fi
                
                if [ "$TIMELINE_NUM" -lt 0 ] || [ "$TIMELINE_NUM" -ge "${#ALL_TIMELINES[@]}" ] 2>/dev/null; then
                    echo "Invalid selection. Please choose 0-$((${#ALL_TIMELINES[@]} - 1))"
                    echo ""
                    continue
                fi
                
                SELECTED_BRANCH="${ALL_TIMELINES[$TIMELINE_NUM]}"
                
                # Show what would change
                echo ""
                echo "üîç Changes that would be applied:"
                echo "================================="
                display_timeline_changes "$SELECTED_BRANCH" HEAD
                echo ""
                
                # Get commit hash for the travel command
                COMMIT_HASH=$(git rev-parse "$SELECTED_BRANCH" 2>/dev/null)
                SHORT_HASH=$(git rev-parse --short "$SELECTED_BRANCH" 2>/dev/null)
                
                # Show resume command in input box style (reusing the UI pattern)
                echo "üìã Resume Command:"
                echo "=================="
                echo ""
                echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
                echo "‚îÇ timeline travel $SHORT_HASH                                ‚îÇ"
                echo "‚îÇ                                                             ‚îÇ"
                echo "‚îÇ [Copy] Copy to clipboard                                    ‚îÇ"
                echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
                echo ""
                
                # Confirm travel
                read -p "Proceed with time travel? (y/N): " CONFIRM
                
                if [[ $CONFIRM =~ ^[Yy]$ ]]; then
                    # Create backup timeline first
                    BACKUP_BRANCH="timelines/$CURRENT_BRANCH/backup-$(date +%s)"
                    git branch "$BACKUP_BRANCH" HEAD 2>/dev/null || true
                    
                    # Perform time travel
                    echo ""
                    echo "üåü Creating backup at: $BACKUP_BRANCH"
                    echo "üöÄ Traveling to timeline: $SELECTED_BRANCH"
                    
                    # Use git restore if available (Git 2.23+), otherwise fallback
                    if git restore --help >/dev/null 2>&1; then
                        git restore --source="$SELECTED_BRANCH" --worktree .
                    else
                        git checkout "$SELECTED_BRANCH" -- .
                    fi
                    
                    echo "‚úÖ Time travel complete!"
                    echo ""
                    echo "üìç You are now at timeline: $SELECTED_BRANCH"
                    echo "üîÑ To return to latest: git restore --source=HEAD --worktree ."
                    echo "üíæ Backup available at: $BACKUP_BRANCH"
                    
                    break
                else
                    echo "Cancelled."
                    break
                fi
            done
            ;;
        "search")
            # Enhanced search across timelines, commit messages, and transcripts
            if [ -z "$2" ]; then
                echo "Usage: timeline search <pattern>"
                echo "  Searches across:"
                echo "    ‚Ä¢ File content and names in timelines"
                echo "    ‚Ä¢ Commit messages"
                echo "    ‚Ä¢ Session transcripts (requires jq)"
                echo ""
                echo "Examples:"
                echo "  timeline search 'auth'       # Find auth-related changes"
                echo "  timeline search 'bug'        # Find bug fixes"
                echo "  timeline search 'test.js'    # Find specific files"
                exit 1
            fi
            
            PATTERN="$2"
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            
            echo "üîç Enhanced Search for '$PATTERN'"
            echo "================================"
            echo ""
            
            # Get all timeline branches
            TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/*" 2>/dev/null))
            
            if [ ${#TIMELINES[@]} -eq 0 ]; then
                echo "No timelines found."
                exit 0
            fi
            
            FOUND_COUNT=0
            CLAUDE_DIR="${CLAUDE_CONFIG_DIR:-$HOME/.claude}"
            
            echo "üìä Search Results:"
            echo "=================="
            echo ""
            
            for timeline in "${TIMELINES[@]}"; do
                # Get timeline info
                commit_time=$(git log -1 --pretty=format:"%cr" "$timeline" 2>/dev/null)
                commit_msg=$(git log -1 --pretty=format:"%s" "$timeline" 2>/dev/null)
                short_hash=$(git rev-parse --short "$timeline" 2>/dev/null)
                
                # Search in file content
                CONTENT_MATCHES=$(git grep -l "$PATTERN" "$timeline" 2>/dev/null || true)
                
                # Search in filenames
                FILE_MATCHES=$(git ls-tree -r --name-only "$timeline" 2>/dev/null | grep "$PATTERN" 2>/dev/null || true)
                
                # Search in commit message
                COMMIT_MATCH=""
                if echo "$commit_msg" | grep -qi "$PATTERN" 2>/dev/null; then
                    COMMIT_MATCH="yes"
                fi
                
                # Search in session transcript (if linked)
                TRANSCRIPT_MATCH=""
                commit_hash=$(git rev-parse "$timeline" 2>/dev/null)
                if [ -n "$commit_hash" ]; then
                    session_id=$(git notes --ref=timeline show "$commit_hash" 2>/dev/null | grep "Session-Id:" | cut -d' ' -f2- | head -1)
                    if [ -n "$session_id" ]; then
                        session_file=$(find "$CLAUDE_DIR/projects" -name "$session_id.jsonl" 2>/dev/null | head -1)
                        
                        if [ -f "$session_file" ] && command -v jq >/dev/null 2>&1; then
                            if grep -q "$PATTERN" "$session_file" 2>/dev/null; then
                                TRANSCRIPT_MATCH="yes"
                            fi
                        fi
                    fi
                fi
                
                # Display results if any matches found
                if [ -n "$CONTENT_MATCHES" ] || [ -n "$FILE_MATCHES" ] || [ -n "$COMMIT_MATCH" ] || [ -n "$TRANSCRIPT_MATCH" ]; then
                    echo "‚≠ê Timeline: $timeline"
                    echo "   üïí $commit_time ‚Ä¢ üè∑Ô∏è  $short_hash"
                    echo "   üí¨ $commit_msg"
                    echo ""
                    
                    # Show commit message match
                    if [ -n "$COMMIT_MATCH" ]; then
                        echo "   ‚úÖ Found in commit message"
                    fi
                    
                    # Show transcript match
                    if [ -n "$TRANSCRIPT_MATCH" ]; then
                        echo "   ‚úÖ Found in session transcript"
                        if [ -f "$session_file" ] && command -v jq >/dev/null 2>&1; then
                            echo "      Recent context:"
                            grep "$PATTERN" "$session_file" | head -2 | while read -r line; do
                                msg_role=$(echo "$line" | jq -r '.role' 2>/dev/null)
                                msg_content=$(echo "$line" | jq -r '.content' 2>/dev/null | head -c 100)
                                echo "      ‚Ä¢ $msg_role: $msg_content..."
                            done
                        fi
                    fi
                    
                    # Show file content matches
                    if [ -n "$CONTENT_MATCHES" ]; then
                        echo "   ‚úÖ Found in file content:"
                        echo "$CONTENT_MATCHES" | while read -r file; do
                            echo "      üìÑ $file"
                            git grep -n "$PATTERN" "$timeline" -- "$file" 2>/dev/null | head -2 | sed 's/^/         /'
                        done
                    fi
                    
                    # Show filename matches
                    if [ -n "$FILE_MATCHES" ]; then
                        echo "   ‚úÖ Found in filenames:"
                        echo "$FILE_MATCHES" | head -3 | sed 's/^/      üìÅ /'
                    fi
                    
                    echo ""
                    echo "   üöÄ Travel command: timeline travel $short_hash"
                    echo ""
                    echo "   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
                    echo ""
                    FOUND_COUNT=$((FOUND_COUNT + 1))
                fi
            done
            
            if [ $FOUND_COUNT -eq 0 ]; then
                echo "No matches found."
            else
                echo "Found matches in $FOUND_COUNT timeline(s)."
            fi
            ;;
        "delete")
            # Interactive timeline deletion
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")
            CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null)
            
            # Get all timeline branches
            ALL_TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/*" 2>/dev/null))
            
            if [ ${#ALL_TIMELINES[@]} -eq 0 ]; then
                echo "No timelines found."
                exit 0
            fi
            
            echo "üóëÔ∏è Timeline Deletion"
            echo "===================="
            
            # Display timelines
            for ((i=0; i<${#ALL_TIMELINES[@]}; i++)); do
                BRANCH="${ALL_TIMELINES[$i]}"
                commit_time=$(git log -1 --pretty=format:"%cr" "$BRANCH" 2>/dev/null)
                commit_msg=$(git log -1 --pretty=format:"%s" "$BRANCH" 2>/dev/null | head -c 60)
                printf "  %2d) %-15s %s\n" "$i" "($commit_time)" "$commit_msg"
            done
            echo ""
            
            read -p "Select timeline to delete (or press Enter to cancel): " TIMELINE_NUM
            
            if [ -z "$TIMELINE_NUM" ]; then
                echo "Cancelled."
                exit 0
            fi
            
            if [ "$TIMELINE_NUM" -lt 0 ] || [ "$TIMELINE_NUM" -ge "${#ALL_TIMELINES[@]}" ] 2>/dev/null; then
                echo "Invalid selection."
                exit 1
            fi
            
            BRANCH="${ALL_TIMELINES[$TIMELINE_NUM]}"
            
            # Confirm deletion
            echo ""
            echo "‚ö†Ô∏è  You are about to delete timeline: $BRANCH"
            read -p "Are you sure? (yes/no): " CONFIRM
            
            if [ "$CONFIRM" = "yes" ]; then
                git branch -D "$BRANCH"
                echo "‚úÖ Deleted timeline: $BRANCH"
            else
                echo "Cancelled."
            fi
            ;;
        "cleanup")
            # Clean up timelines for deleted branches
            echo "üßπ Cleaning up timelines for deleted branches..."
            echo ""
            
            # Get all timeline branch prefixes
            TIMELINE_PREFIXES=($(git for-each-ref --format='%(refname:short)' 'refs/heads/timelines/*' 2>/dev/null | sed 's|/.*||' | sort -u | sed 's|timelines/||'))
            
            CLEANED_COUNT=0
            
            for branch_name in "${TIMELINE_PREFIXES[@]}"; do
                # Check if the actual branch still exists
                if ! git show-ref --verify --quiet "refs/heads/$branch_name" 2>/dev/null; then
                    echo "Found orphaned timelines for deleted branch: $branch_name"
                    
                    # Get all timelines for this branch
                    ORPHAN_TIMELINES=($(git for-each-ref --format='%(refname:short)' "refs/heads/timelines/$branch_name/*" 2>/dev/null))
                    
                    if [ ${#ORPHAN_TIMELINES[@]} -gt 0 ]; then
                        echo "  Removing ${#ORPHAN_TIMELINES[@]} timeline(s)..."
                        for timeline in "${ORPHAN_TIMELINES[@]}"; do
                            git branch -D "$timeline" 2>/dev/null
                            CLEANED_COUNT=$((CLEANED_COUNT + 1))
                        done
                    fi
                fi
            done
            
            if [ $CLEANED_COUNT -eq 0 ]; then
                echo "No orphaned timelines found."
            else
                echo ""
                echo "‚úÖ Cleaned up $CLEANED_COUNT orphaned timeline(s)."
            fi
            ;;
        "install"|"uninstall")
            # These are handled at the beginning of the script
            ;;
    esac
else
    # No arguments - show help
    echo "Usage:"
    echo "  timeline save             - Create a timeline manually"
    echo "  timeline travel           - Show timelines and travel interactively"
    echo "  timeline view             - Visual HTML view of all timelines"
    echo "  timeline browse           - Browse files in a specific timeline"
    echo "  timeline search [pattern] - Search for text across timelines"
    echo "  timeline delete           - Delete timelines interactively"
    echo "  timeline cleanup          - Clean up timelines for deleted branches"
    echo "  timeline install          - Install hook to Claude Code"
    echo "  timeline uninstall        - Remove hook from Claude Code"
    exit 0
fi

# Check if we're in a git repo first
if ! git rev-parse --git-dir >/dev/null 2>&1; then
    # Not a git repo, exit silently
    exit 0
fi

# Debug logging
DEBUG_ENABLED_FILE="/tmp/timeline_debug_enabled"

if [ -f "$DEBUG_ENABLED_FILE" ] || [ "$1" = "--debug" ]; then
    # Read debug log path from file, or use default
    if [ -f "$DEBUG_ENABLED_FILE" ] && [ -s "$DEBUG_ENABLED_FILE" ]; then
        DEBUG_LOG=$(cat "$DEBUG_ENABLED_FILE")
    else
        DEBUG_LOG="/tmp/timeline-debug.log"
    fi
    exec 3>> "$DEBUG_LOG"
    echo "=== Timeline Debug Session $(date) ===" >&3
    echo "Command: $0 $*" >&3
    echo "PWD: $(pwd)" >&3
    echo "Environment variables:" >&3
    env | grep -E "(CLAUDE|SESSION|TOOL|HOOK)" | sort >&3
    echo "Stdin available: $([ ! -t 0 ] && echo 'yes' || echo 'no')" >&3
    if [ ! -t 0 ]; then
        echo "Stdin data (full JSON):" >&3
        cat > /tmp/timeline-stdin.log
        # Pretty print JSON if it's valid JSON
        if command -v jq >/dev/null 2>&1 && jq empty < /tmp/timeline-stdin.log 2>/dev/null; then
            jq '.' /tmp/timeline-stdin.log >&3
        else
            cat /tmp/timeline-stdin.log >&3
        fi
    fi
    echo "Arguments: $@" >&3
    echo "========================" >&3
fi

# Get current branch and last timeline
CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "main")
# Ensure branch name is not empty (fallback to main)
if [ -z "$CURRENT_BRANCH" ]; then
    CURRENT_BRANCH="main"
fi
LAST_TIMELINE=$(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | grep -v '/backup-' | head -1)

# Always check against last timeline if it exists
if [ -n "$LAST_TIMELINE" ]; then
    # Create a temporary index for the last timeline to compare untracked files
    export GIT_INDEX_FILE=$(mktemp)
    git read-tree "$LAST_TIMELINE" >/dev/null 2>&1
    LAST_TREE=$(git write-tree 2>/dev/null)
    rm -f $GIT_INDEX_FILE
    unset GIT_INDEX_FILE
    
    # Create a temporary index for current state
    export GIT_INDEX_FILE=$(mktemp)
    git read-tree HEAD >/dev/null 2>&1
    git add --all >/dev/null 2>&1
    CURRENT_TREE=$(git write-tree 2>/dev/null)
    rm -f $GIT_INDEX_FILE
    unset GIT_INDEX_FILE
    
    # If the trees are identical, no changes since last timeline
    if [ "$LAST_TREE" = "$CURRENT_TREE" ]; then
        # No changes since last timeline, exit silently
        exit 0
    fi
else
    # No previous timeline exists, check if there are any changes from HEAD
    if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null || [ -n "$(git ls-files --others --exclude-standard 2>/dev/null)" ]; then
        # Changes exist, continue to create timeline
        :
    else
        # No changes from HEAD and no previous timeline, exit silently
        exit 0
    fi
fi

# Get the commit message of current HEAD
COMMIT_MSG=$(git log -1 --pretty=format:"%s" HEAD)
SHORT_HEAD=$(git rev-parse --short HEAD)

# Find the next timeline number
TIMELINE_NUM=0
EXISTING_TIMELINES=$(git branch --list "timelines/$CURRENT_BRANCH/+*" 2>/dev/null | sed 's/^[\* ]*//')
if [ -n "$EXISTING_TIMELINES" ]; then
    for branch in $EXISTING_TIMELINES; do
        if git log -1 --pretty=format:"%s" "$branch" 2>/dev/null | grep -q "@$SHORT_HEAD"; then
            num=$(echo "$branch" | sed -n "s|timelines/$CURRENT_BRANCH/+\([0-9]*\).*|\1|p")
            if [ -n "$num" ] && [ "$num" -ge "$TIMELINE_NUM" ]; then
                TIMELINE_NUM=$((num + 1))
            fi
        fi
    done
fi

# Create timeline branch name
SAFE_MSG=$(echo "$COMMIT_MSG" | sed 's/[^a-zA-Z0-9._-]/_/g' | cut -c1-50)
TIMELINE_BRANCH="timelines/$CURRENT_BRANCH/+${TIMELINE_NUM}_${SAFE_MSG}"

# Create timeline using git plumbing commands
export GIT_INDEX_FILE=$(mktemp)
trap "rm -f $GIT_INDEX_FILE" EXIT

git read-tree HEAD >/dev/null 2>&1
git add --all >/dev/null 2>&1
TREE_SHA=$(git write-tree)

TIMELINE_MSG="Timeline +$TIMELINE_NUM @$SHORT_HEAD: $COMMIT_MSG"
COMMIT_SHA=$(echo "$TIMELINE_MSG" | git commit-tree $TREE_SHA -p HEAD)
git update-ref "refs/heads/$TIMELINE_BRANCH" $COMMIT_SHA

# Try to detect and link Claude session ID
SESSION_ID=""

# Method 1: Check environment variables
for var in CLAUDE_SESSION_ID SESSION_ID TOOL_SESSION_ID HOOK_SESSION_ID; do
    if [ -n "${!var}" ]; then
        SESSION_ID="${!var}"
        [ -f "$DEBUG_ENABLED_FILE" ] && echo "Found session ID from env var $var: $SESSION_ID" >&3
        break
    fi
done

# Method 2: Check stdin data if available
if [ -z "$SESSION_ID" ] && [ -f "/tmp/timeline-stdin.log" ]; then
    # Look for session ID patterns in stdin
    if grep -q -E '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}' /tmp/timeline-stdin.log; then
        SESSION_ID=$(grep -oE '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}' /tmp/timeline-stdin.log | head -1)
        [ -f "$DEBUG_ENABLED_FILE" ] && echo "Found session ID from stdin: $SESSION_ID" >&3
    fi
fi

# Method 3: Try to extract from current session files
if [ -z "$SESSION_ID" ]; then
    # Look for recently modified session files
    CLAUDE_DIR="${CLAUDE_CONFIG_DIR:-$HOME/.claude}"
    if [ -d "$CLAUDE_DIR/projects" ]; then
        RECENT_SESSION=$(find "$CLAUDE_DIR/projects" -name "*.jsonl" -type f -exec stat -f "%m %N" {} \; 2>/dev/null | sort -nr | head -1 | cut -d' ' -f2-)
        if [ -n "$RECENT_SESSION" ]; then
            SESSION_ID=$(basename "$RECENT_SESSION" .jsonl)
            [ -f "$DEBUG_ENABLED_FILE" ] && echo "Found session ID from recent file: $SESSION_ID" >&3
        fi
    fi
fi

# Add session ID as git note if found
if [ -n "$SESSION_ID" ]; then
    echo "Session-Id: $SESSION_ID" | git notes --ref=timeline add -F - "$COMMIT_SHA" 2>/dev/null
    [ -f "$DEBUG_ENABLED_FILE" ] && echo "Added session ID note: $SESSION_ID" >&3
else
    [ -f "$DEBUG_ENABLED_FILE" ] && echo "No session ID found" >&3
fi

rm -f $GIT_INDEX_FILE
unset GIT_INDEX_FILE

# Clean up old timelines (keep only last 20)
OLD_TIMELINES=($(git for-each-ref --sort=-committerdate --format='%(refname:short)' "refs/heads/timelines/$CURRENT_BRANCH/" 2>/dev/null | tail -n +21))
for old_timeline in "${OLD_TIMELINES[@]}"; do
    git branch -D "$old_timeline" >/dev/null 2>&1
done
